// Package oscp_v20 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.0 DO NOT EDIT.
package oscp_v20

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for AssetCategory.
const (
	AssetCategoryCHARGING    AssetCategory = "CHARGING"
	AssetCategoryCONSUMPTION AssetCategory = "CONSUMPTION"
	AssetCategoryGENERATION  AssetCategory = "GENERATION"
	AssetCategorySTORAGE     AssetCategory = "STORAGE"
)

// Defines values for CapacityForecastType.
const (
	CapacityForecastTypeCONSUMPTION         CapacityForecastType = "CONSUMPTION"
	CapacityForecastTypeFALLBACKCONSUMPTION CapacityForecastType = "FALLBACK_CONSUMPTION"
	CapacityForecastTypeFALLBACKGENERATION  CapacityForecastType = "FALLBACK_GENERATION"
	CapacityForecastTypeGENERATION          CapacityForecastType = "GENERATION"
	CapacityForecastTypeOPTIMUM             CapacityForecastType = "OPTIMUM"
)

// Defines values for EnergyFlowDirection.
const (
	EXPORT EnergyFlowDirection = "EXPORT"
	IMPORT EnergyFlowDirection = "IMPORT"
	NET    EnergyFlowDirection = "NET"
)

// Defines values for EnergyMeasurementUnit.
const (
	EnergyMeasurementUnitKWH EnergyMeasurementUnit = "KWH"
	EnergyMeasurementUnitWH  EnergyMeasurementUnit = "WH"
)

// Defines values for EnergyType.
const (
	FLEXIBLE    EnergyType = "FLEXIBLE"
	NONFLEXIBLE EnergyType = "NONFLEXIBLE"
	TOTAL       EnergyType = "TOTAL"
)

// Defines values for ForecastedBlockUnit.
const (
	ForecastedBlockUnitA   ForecastedBlockUnit = "A"
	ForecastedBlockUnitKW  ForecastedBlockUnit = "KW"
	ForecastedBlockUnitKWH ForecastedBlockUnit = "KWH"
	ForecastedBlockUnitW   ForecastedBlockUnit = "W"
	ForecastedBlockUnitWH  ForecastedBlockUnit = "WH"
)

// Defines values for InstantaneousMeasurementUnit.
const (
	A   InstantaneousMeasurementUnit = "A"
	KW  InstantaneousMeasurementUnit = "KW"
	KWH InstantaneousMeasurementUnit = "KWH"
	W   InstantaneousMeasurementUnit = "W"
	WH  InstantaneousMeasurementUnit = "WH"
)

// Defines values for MeasurementConfiguration.
const (
	CONTINUOUS   MeasurementConfiguration = "CONTINUOUS"
	INTERMITTENT MeasurementConfiguration = "INTERMITTENT"
)

// Defines values for PhaseIndicator.
const (
	ALL     PhaseIndicator = "ALL"
	ONE     PhaseIndicator = "ONE"
	THREE   PhaseIndicator = "THREE"
	TWO     PhaseIndicator = "TWO"
	UNKNOWN PhaseIndicator = "UNKNOWN"
)

// AssetCategory defines model for AssetCategory.
type AssetCategory string

// AssetMeasurement defines model for AssetMeasurement.
type AssetMeasurement struct {
	AssetCategory            string                    `json:"asset_category"`
	AssetId                  string                    `json:"asset_id"`
	EnergyMeasurement        *EnergyMeasurement        `json:"energy_measurement,omitempty"`
	InstantaneousMeasurement *InstantaneousMeasurement `json:"instantaneous_measurement,omitempty"`
}

// CapacityForecastType defines model for CapacityForecastType.
type CapacityForecastType string

// EnergyFlowDirection defines model for EnergyFlowDirection.
type EnergyFlowDirection string

// EnergyMeasurement defines model for EnergyMeasurement.
type EnergyMeasurement struct {
	Direction          EnergyFlowDirection   `json:"direction"`
	EnergyType         *EnergyType           `json:"energy_type,omitempty"`
	InitialMeasureTime *time.Time            `json:"initial_measure_time,omitempty"`
	MeasureTime        time.Time             `json:"measure_time"`
	Phase              PhaseIndicator        `json:"phase"`
	Unit               EnergyMeasurementUnit `json:"unit"`
	Value              float64               `json:"value"`
}

// EnergyMeasurementUnit defines model for EnergyMeasurementUnit.
type EnergyMeasurementUnit string

// EnergyType defines model for EnergyType.
type EnergyType string

// ErrorBody defines model for ErrorBody.
type ErrorBody struct {
	Message *string `json:"message,omitempty"`
}

// ForecastedBlock defines model for ForecastedBlock.
type ForecastedBlock struct {
	Capacity  string              `json:"capacity"`
	EndTime   time.Time           `json:"end_time"`
	Phase     PhaseIndicator      `json:"phase"`
	StartTime time.Time           `json:"start_time"`
	Unit      ForecastedBlockUnit `json:"unit"`
}

// ForecastedBlockUnit defines model for ForecastedBlockUnit.
type ForecastedBlockUnit string

// GroupCapacityForecast defines model for GroupCapacityForecast.
type GroupCapacityForecast struct {
	ForecastedBlocks []ForecastedBlock    `json:"forecasted_blocks"`
	GroupId          string               `json:"group_id"`
	Type             CapacityForecastType `json:"type"`
}

// GroupComplianceError defines model for GroupComplianceError.
type GroupComplianceError struct {
	ForecastedBlocks *[]ForecastedBlock `json:"forecasted_blocks,omitempty"`
	Message          string             `json:"message"`
}

// Heartbeat defines model for Heartbeat.
type Heartbeat struct {
	// OfflineModeAt A time in the future that indicates when, in case no more heartbeat
	// messages are received, it can be assumed the receiving party is
	// offline (unavailable). This time SHOULD be updated with every
	// heartbeat message.
	OfflineModeAt *time.Time `json:"offline_mode_at,omitempty"`
}

// InstantaneousMeasurement defines model for InstantaneousMeasurement.
type InstantaneousMeasurement struct {
	MeasureTime time.Time                    `json:"measure_time"`
	Phase       PhaseIndicator               `json:"phase"`
	Unit        InstantaneousMeasurementUnit `json:"unit"`
	Value       float64                      `json:"value"`
}

// InstantaneousMeasurementUnit defines model for InstantaneousMeasurementUnit.
type InstantaneousMeasurementUnit string

// MeasurementConfiguration defines model for MeasurementConfiguration.
type MeasurementConfiguration string

// PhaseIndicator defines model for PhaseIndicator.
type PhaseIndicator string

// Registration defines model for Registration.
type Registration struct {
	Token      string       `json:"token"`
	VersionUrl []VersionURL `json:"version_url"`
}

// RequiredBehaviour defines model for RequiredBehaviour.
type RequiredBehaviour struct {
	// HeartbeatInterval The interval (in seconds) in which the
	// sender of this response expects heartbeats to
	// receive. If provided, value must be 1 or higher.
	// If the sender is not interested in the heartbeat
	// of the receiver, this field can be omitted.
	HeartbeatInterval *int `json:"heartbeat_interval,omitempty"`

	// MeasurementConfiguration For determining how measurements are
	// aggregated. Providing multiple configurations
	// is allowed. An empty array represents no
	// configurations.
	MeasurementConfiguration *[]MeasurementConfiguration `json:"measurement_configuration,omitempty"`
}

// UpdateAssetMeasurements defines model for UpdateAssetMeasurements.
type UpdateAssetMeasurements struct {
	GroupId      string             `json:"group_id"`
	Measurements []AssetMeasurement `json:"measurements"`
}

// UpdateGroupMeasurements defines model for UpdateGroupMeasurements.
type UpdateGroupMeasurements struct {
	GroupId      string              `json:"group_id"`
	Measurements []EnergyMeasurement `json:"measurements"`
}

// VersionURL defines model for VersionURL.
type VersionURL struct {
	// BaseUrl Base URL of the API
	BaseUrl string `json:"base_url"`

	// Version Version of the API
	Version string `json:"version"`
}

// Authorization defines model for Authorization.
type Authorization = string

// XCorrelationID defines model for X-Correlation-ID.
type XCorrelationID = string

// XRequestID defines model for X-Request-ID.
type XRequestID = string

// XSegmentCount defines model for X-Segment-Count.
type XSegmentCount = int

// XSegmentIndex defines model for X-Segment-Index.
type XSegmentIndex = int

// AdjustGroupCapacityForecast defines model for AdjustGroupCapacityForecast.
type AdjustGroupCapacityForecast = GroupCapacityForecast

// GroupCapacityComplianceError defines model for GroupCapacityComplianceError.
type GroupCapacityComplianceError = GroupComplianceError

// Handshake defines model for Handshake.
type Handshake = RequiredBehaviour

// HandshakeAcknowledge defines model for HandshakeAcknowledge.
type HandshakeAcknowledge = RequiredBehaviour

// UpdateGroupCapacityForecast defines model for UpdateGroupCapacityForecast.
type UpdateGroupCapacityForecast = GroupCapacityForecast

// HandshakeCapacityOptimizerParams defines parameters for HandshakeCapacityOptimizer.
type HandshakeCapacityOptimizerParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// HeartbeatCapacityOptimizerParams defines parameters for HeartbeatCapacityOptimizer.
type HeartbeatCapacityOptimizerParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UnregisterCapacityOptimizerParams defines parameters for UnregisterCapacityOptimizer.
type UnregisterCapacityOptimizerParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// RegisterCapacityOptimizerParams defines parameters for RegisterCapacityOptimizer.
type RegisterCapacityOptimizerParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UpdateRegistrationCapacityOptimizerParams defines parameters for UpdateRegistrationCapacityOptimizer.
type UpdateRegistrationCapacityOptimizerParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UpdateAssetMeasurementsCapacityOptimizerParams defines parameters for UpdateAssetMeasurementsCapacityOptimizer.
type UpdateAssetMeasurementsCapacityOptimizerParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UpdateGroupCapacityForecastCapacityOptimizerParams defines parameters for UpdateGroupCapacityForecastCapacityOptimizer.
type UpdateGroupCapacityForecastCapacityOptimizerParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// AdjustGroupCapacityForecastCapacityProviderParams defines parameters for AdjustGroupCapacityForecastCapacityProvider.
type AdjustGroupCapacityForecastCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// GroupCapacityComplianceErrorCapacityProviderParams defines parameters for GroupCapacityComplianceErrorCapacityProvider.
type GroupCapacityComplianceErrorCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// HandshakeAcknowledgeCapacityProviderParams defines parameters for HandshakeAcknowledgeCapacityProvider.
type HandshakeAcknowledgeCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// HeartbeatCapacityProviderParams defines parameters for HeartbeatCapacityProvider.
type HeartbeatCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UnregisterCapacityProviderParams defines parameters for UnregisterCapacityProvider.
type UnregisterCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// RegisterCapacityProviderParams defines parameters for RegisterCapacityProvider.
type RegisterCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UpdateRegistrationCapacityProviderParams defines parameters for UpdateRegistrationCapacityProvider.
type UpdateRegistrationCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UpdateGroupMeasurementsCapacityProviderParams defines parameters for UpdateGroupMeasurementsCapacityProvider.
type UpdateGroupMeasurementsCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// HandshakeFlexibilityProviderParams defines parameters for HandshakeFlexibilityProvider.
type HandshakeFlexibilityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// HandshakeAcknowledgeFlexibilityProviderParams defines parameters for HandshakeAcknowledgeFlexibilityProvider.
type HandshakeAcknowledgeFlexibilityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// HeartbeatFlexibilityProviderParams defines parameters for HeartbeatFlexibilityProvider.
type HeartbeatFlexibilityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UnregisterFlexibilityProviderParams defines parameters for UnregisterFlexibilityProvider.
type UnregisterFlexibilityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// RegisterFlexibilityProviderParams defines parameters for RegisterFlexibilityProvider.
type RegisterFlexibilityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UpdateRegistrationFlexibilityProviderParams defines parameters for UpdateRegistrationFlexibilityProvider.
type UpdateRegistrationFlexibilityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UpdateGroupCapacityForecastFlexibilityProviderParams defines parameters for UpdateGroupCapacityForecastFlexibilityProvider.
type UpdateGroupCapacityForecastFlexibilityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// HandshakeCapacityOptimizerJSONRequestBody defines body for HandshakeCapacityOptimizer for application/json ContentType.
type HandshakeCapacityOptimizerJSONRequestBody = RequiredBehaviour

// HeartbeatCapacityOptimizerJSONRequestBody defines body for HeartbeatCapacityOptimizer for application/json ContentType.
type HeartbeatCapacityOptimizerJSONRequestBody = Heartbeat

// UnregisterCapacityOptimizerJSONRequestBody defines body for UnregisterCapacityOptimizer for application/json ContentType.
type UnregisterCapacityOptimizerJSONRequestBody = Registration

// RegisterCapacityOptimizerJSONRequestBody defines body for RegisterCapacityOptimizer for application/json ContentType.
type RegisterCapacityOptimizerJSONRequestBody = Registration

// UpdateRegistrationCapacityOptimizerJSONRequestBody defines body for UpdateRegistrationCapacityOptimizer for application/json ContentType.
type UpdateRegistrationCapacityOptimizerJSONRequestBody = Registration

// UpdateAssetMeasurementsCapacityOptimizerJSONRequestBody defines body for UpdateAssetMeasurementsCapacityOptimizer for application/json ContentType.
type UpdateAssetMeasurementsCapacityOptimizerJSONRequestBody = UpdateAssetMeasurements

// UpdateGroupCapacityForecastCapacityOptimizerJSONRequestBody defines body for UpdateGroupCapacityForecastCapacityOptimizer for application/json ContentType.
type UpdateGroupCapacityForecastCapacityOptimizerJSONRequestBody = GroupCapacityForecast

// AdjustGroupCapacityForecastCapacityProviderJSONRequestBody defines body for AdjustGroupCapacityForecastCapacityProvider for application/json ContentType.
type AdjustGroupCapacityForecastCapacityProviderJSONRequestBody = GroupCapacityForecast

// GroupCapacityComplianceErrorCapacityProviderJSONRequestBody defines body for GroupCapacityComplianceErrorCapacityProvider for application/json ContentType.
type GroupCapacityComplianceErrorCapacityProviderJSONRequestBody = GroupComplianceError

// HandshakeAcknowledgeCapacityProviderJSONRequestBody defines body for HandshakeAcknowledgeCapacityProvider for application/json ContentType.
type HandshakeAcknowledgeCapacityProviderJSONRequestBody = RequiredBehaviour

// HeartbeatCapacityProviderJSONRequestBody defines body for HeartbeatCapacityProvider for application/json ContentType.
type HeartbeatCapacityProviderJSONRequestBody = Heartbeat

// UnregisterCapacityProviderJSONRequestBody defines body for UnregisterCapacityProvider for application/json ContentType.
type UnregisterCapacityProviderJSONRequestBody = Registration

// RegisterCapacityProviderJSONRequestBody defines body for RegisterCapacityProvider for application/json ContentType.
type RegisterCapacityProviderJSONRequestBody = Registration

// UpdateRegistrationCapacityProviderJSONRequestBody defines body for UpdateRegistrationCapacityProvider for application/json ContentType.
type UpdateRegistrationCapacityProviderJSONRequestBody = Registration

// UpdateGroupMeasurementsCapacityProviderJSONRequestBody defines body for UpdateGroupMeasurementsCapacityProvider for application/json ContentType.
type UpdateGroupMeasurementsCapacityProviderJSONRequestBody = UpdateGroupMeasurements

// HandshakeFlexibilityProviderJSONRequestBody defines body for HandshakeFlexibilityProvider for application/json ContentType.
type HandshakeFlexibilityProviderJSONRequestBody = RequiredBehaviour

// HandshakeAcknowledgeFlexibilityProviderJSONRequestBody defines body for HandshakeAcknowledgeFlexibilityProvider for application/json ContentType.
type HandshakeAcknowledgeFlexibilityProviderJSONRequestBody = RequiredBehaviour

// HeartbeatFlexibilityProviderJSONRequestBody defines body for HeartbeatFlexibilityProvider for application/json ContentType.
type HeartbeatFlexibilityProviderJSONRequestBody = Heartbeat

// UnregisterFlexibilityProviderJSONRequestBody defines body for UnregisterFlexibilityProvider for application/json ContentType.
type UnregisterFlexibilityProviderJSONRequestBody = Registration

// RegisterFlexibilityProviderJSONRequestBody defines body for RegisterFlexibilityProvider for application/json ContentType.
type RegisterFlexibilityProviderJSONRequestBody = Registration

// UpdateRegistrationFlexibilityProviderJSONRequestBody defines body for UpdateRegistrationFlexibilityProvider for application/json ContentType.
type UpdateRegistrationFlexibilityProviderJSONRequestBody = Registration

// UpdateGroupCapacityForecastFlexibilityProviderJSONRequestBody defines body for UpdateGroupCapacityForecastFlexibilityProvider for application/json ContentType.
type UpdateGroupCapacityForecastFlexibilityProviderJSONRequestBody = GroupCapacityForecast

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// HandshakeCapacityOptimizerWithBody request with any body
	HandshakeCapacityOptimizerWithBody(ctx context.Context, params *HandshakeCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	HandshakeCapacityOptimizer(ctx context.Context, params *HandshakeCapacityOptimizerParams, body HandshakeCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeartbeatCapacityOptimizerWithBody request with any body
	HeartbeatCapacityOptimizerWithBody(ctx context.Context, params *HeartbeatCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	HeartbeatCapacityOptimizer(ctx context.Context, params *HeartbeatCapacityOptimizerParams, body HeartbeatCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnregisterCapacityOptimizerWithBody request with any body
	UnregisterCapacityOptimizerWithBody(ctx context.Context, params *UnregisterCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnregisterCapacityOptimizer(ctx context.Context, params *UnregisterCapacityOptimizerParams, body UnregisterCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterCapacityOptimizerWithBody request with any body
	RegisterCapacityOptimizerWithBody(ctx context.Context, params *RegisterCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterCapacityOptimizer(ctx context.Context, params *RegisterCapacityOptimizerParams, body RegisterCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRegistrationCapacityOptimizerWithBody request with any body
	UpdateRegistrationCapacityOptimizerWithBody(ctx context.Context, params *UpdateRegistrationCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRegistrationCapacityOptimizer(ctx context.Context, params *UpdateRegistrationCapacityOptimizerParams, body UpdateRegistrationCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAssetMeasurementsCapacityOptimizerWithBody request with any body
	UpdateAssetMeasurementsCapacityOptimizerWithBody(ctx context.Context, params *UpdateAssetMeasurementsCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAssetMeasurementsCapacityOptimizer(ctx context.Context, params *UpdateAssetMeasurementsCapacityOptimizerParams, body UpdateAssetMeasurementsCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGroupCapacityForecastCapacityOptimizerWithBody request with any body
	UpdateGroupCapacityForecastCapacityOptimizerWithBody(ctx context.Context, params *UpdateGroupCapacityForecastCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGroupCapacityForecastCapacityOptimizer(ctx context.Context, params *UpdateGroupCapacityForecastCapacityOptimizerParams, body UpdateGroupCapacityForecastCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdjustGroupCapacityForecastCapacityProviderWithBody request with any body
	AdjustGroupCapacityForecastCapacityProviderWithBody(ctx context.Context, params *AdjustGroupCapacityForecastCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AdjustGroupCapacityForecastCapacityProvider(ctx context.Context, params *AdjustGroupCapacityForecastCapacityProviderParams, body AdjustGroupCapacityForecastCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupCapacityComplianceErrorCapacityProviderWithBody request with any body
	GroupCapacityComplianceErrorCapacityProviderWithBody(ctx context.Context, params *GroupCapacityComplianceErrorCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupCapacityComplianceErrorCapacityProvider(ctx context.Context, params *GroupCapacityComplianceErrorCapacityProviderParams, body GroupCapacityComplianceErrorCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HandshakeAcknowledgeCapacityProviderWithBody request with any body
	HandshakeAcknowledgeCapacityProviderWithBody(ctx context.Context, params *HandshakeAcknowledgeCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	HandshakeAcknowledgeCapacityProvider(ctx context.Context, params *HandshakeAcknowledgeCapacityProviderParams, body HandshakeAcknowledgeCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeartbeatCapacityProviderWithBody request with any body
	HeartbeatCapacityProviderWithBody(ctx context.Context, params *HeartbeatCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	HeartbeatCapacityProvider(ctx context.Context, params *HeartbeatCapacityProviderParams, body HeartbeatCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnregisterCapacityProviderWithBody request with any body
	UnregisterCapacityProviderWithBody(ctx context.Context, params *UnregisterCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnregisterCapacityProvider(ctx context.Context, params *UnregisterCapacityProviderParams, body UnregisterCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterCapacityProviderWithBody request with any body
	RegisterCapacityProviderWithBody(ctx context.Context, params *RegisterCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterCapacityProvider(ctx context.Context, params *RegisterCapacityProviderParams, body RegisterCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRegistrationCapacityProviderWithBody request with any body
	UpdateRegistrationCapacityProviderWithBody(ctx context.Context, params *UpdateRegistrationCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRegistrationCapacityProvider(ctx context.Context, params *UpdateRegistrationCapacityProviderParams, body UpdateRegistrationCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGroupMeasurementsCapacityProviderWithBody request with any body
	UpdateGroupMeasurementsCapacityProviderWithBody(ctx context.Context, params *UpdateGroupMeasurementsCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGroupMeasurementsCapacityProvider(ctx context.Context, params *UpdateGroupMeasurementsCapacityProviderParams, body UpdateGroupMeasurementsCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HandshakeFlexibilityProviderWithBody request with any body
	HandshakeFlexibilityProviderWithBody(ctx context.Context, params *HandshakeFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	HandshakeFlexibilityProvider(ctx context.Context, params *HandshakeFlexibilityProviderParams, body HandshakeFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HandshakeAcknowledgeFlexibilityProviderWithBody request with any body
	HandshakeAcknowledgeFlexibilityProviderWithBody(ctx context.Context, params *HandshakeAcknowledgeFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	HandshakeAcknowledgeFlexibilityProvider(ctx context.Context, params *HandshakeAcknowledgeFlexibilityProviderParams, body HandshakeAcknowledgeFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeartbeatFlexibilityProviderWithBody request with any body
	HeartbeatFlexibilityProviderWithBody(ctx context.Context, params *HeartbeatFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	HeartbeatFlexibilityProvider(ctx context.Context, params *HeartbeatFlexibilityProviderParams, body HeartbeatFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnregisterFlexibilityProviderWithBody request with any body
	UnregisterFlexibilityProviderWithBody(ctx context.Context, params *UnregisterFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnregisterFlexibilityProvider(ctx context.Context, params *UnregisterFlexibilityProviderParams, body UnregisterFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterFlexibilityProviderWithBody request with any body
	RegisterFlexibilityProviderWithBody(ctx context.Context, params *RegisterFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterFlexibilityProvider(ctx context.Context, params *RegisterFlexibilityProviderParams, body RegisterFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRegistrationFlexibilityProviderWithBody request with any body
	UpdateRegistrationFlexibilityProviderWithBody(ctx context.Context, params *UpdateRegistrationFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRegistrationFlexibilityProvider(ctx context.Context, params *UpdateRegistrationFlexibilityProviderParams, body UpdateRegistrationFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGroupCapacityForecastFlexibilityProviderWithBody request with any body
	UpdateGroupCapacityForecastFlexibilityProviderWithBody(ctx context.Context, params *UpdateGroupCapacityForecastFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGroupCapacityForecastFlexibilityProvider(ctx context.Context, params *UpdateGroupCapacityForecastFlexibilityProviderParams, body UpdateGroupCapacityForecastFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) HandshakeCapacityOptimizerWithBody(ctx context.Context, params *HandshakeCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHandshakeCapacityOptimizerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HandshakeCapacityOptimizer(ctx context.Context, params *HandshakeCapacityOptimizerParams, body HandshakeCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHandshakeCapacityOptimizerRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeartbeatCapacityOptimizerWithBody(ctx context.Context, params *HeartbeatCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeartbeatCapacityOptimizerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeartbeatCapacityOptimizer(ctx context.Context, params *HeartbeatCapacityOptimizerParams, body HeartbeatCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeartbeatCapacityOptimizerRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnregisterCapacityOptimizerWithBody(ctx context.Context, params *UnregisterCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnregisterCapacityOptimizerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnregisterCapacityOptimizer(ctx context.Context, params *UnregisterCapacityOptimizerParams, body UnregisterCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnregisterCapacityOptimizerRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterCapacityOptimizerWithBody(ctx context.Context, params *RegisterCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterCapacityOptimizerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterCapacityOptimizer(ctx context.Context, params *RegisterCapacityOptimizerParams, body RegisterCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterCapacityOptimizerRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRegistrationCapacityOptimizerWithBody(ctx context.Context, params *UpdateRegistrationCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRegistrationCapacityOptimizerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRegistrationCapacityOptimizer(ctx context.Context, params *UpdateRegistrationCapacityOptimizerParams, body UpdateRegistrationCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRegistrationCapacityOptimizerRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetMeasurementsCapacityOptimizerWithBody(ctx context.Context, params *UpdateAssetMeasurementsCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetMeasurementsCapacityOptimizerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetMeasurementsCapacityOptimizer(ctx context.Context, params *UpdateAssetMeasurementsCapacityOptimizerParams, body UpdateAssetMeasurementsCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetMeasurementsCapacityOptimizerRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupCapacityForecastCapacityOptimizerWithBody(ctx context.Context, params *UpdateGroupCapacityForecastCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupCapacityForecastCapacityOptimizerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupCapacityForecastCapacityOptimizer(ctx context.Context, params *UpdateGroupCapacityForecastCapacityOptimizerParams, body UpdateGroupCapacityForecastCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupCapacityForecastCapacityOptimizerRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdjustGroupCapacityForecastCapacityProviderWithBody(ctx context.Context, params *AdjustGroupCapacityForecastCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdjustGroupCapacityForecastCapacityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdjustGroupCapacityForecastCapacityProvider(ctx context.Context, params *AdjustGroupCapacityForecastCapacityProviderParams, body AdjustGroupCapacityForecastCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdjustGroupCapacityForecastCapacityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupCapacityComplianceErrorCapacityProviderWithBody(ctx context.Context, params *GroupCapacityComplianceErrorCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupCapacityComplianceErrorCapacityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupCapacityComplianceErrorCapacityProvider(ctx context.Context, params *GroupCapacityComplianceErrorCapacityProviderParams, body GroupCapacityComplianceErrorCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupCapacityComplianceErrorCapacityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HandshakeAcknowledgeCapacityProviderWithBody(ctx context.Context, params *HandshakeAcknowledgeCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHandshakeAcknowledgeCapacityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HandshakeAcknowledgeCapacityProvider(ctx context.Context, params *HandshakeAcknowledgeCapacityProviderParams, body HandshakeAcknowledgeCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHandshakeAcknowledgeCapacityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeartbeatCapacityProviderWithBody(ctx context.Context, params *HeartbeatCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeartbeatCapacityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeartbeatCapacityProvider(ctx context.Context, params *HeartbeatCapacityProviderParams, body HeartbeatCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeartbeatCapacityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnregisterCapacityProviderWithBody(ctx context.Context, params *UnregisterCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnregisterCapacityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnregisterCapacityProvider(ctx context.Context, params *UnregisterCapacityProviderParams, body UnregisterCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnregisterCapacityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterCapacityProviderWithBody(ctx context.Context, params *RegisterCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterCapacityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterCapacityProvider(ctx context.Context, params *RegisterCapacityProviderParams, body RegisterCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterCapacityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRegistrationCapacityProviderWithBody(ctx context.Context, params *UpdateRegistrationCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRegistrationCapacityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRegistrationCapacityProvider(ctx context.Context, params *UpdateRegistrationCapacityProviderParams, body UpdateRegistrationCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRegistrationCapacityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupMeasurementsCapacityProviderWithBody(ctx context.Context, params *UpdateGroupMeasurementsCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupMeasurementsCapacityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupMeasurementsCapacityProvider(ctx context.Context, params *UpdateGroupMeasurementsCapacityProviderParams, body UpdateGroupMeasurementsCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupMeasurementsCapacityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HandshakeFlexibilityProviderWithBody(ctx context.Context, params *HandshakeFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHandshakeFlexibilityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HandshakeFlexibilityProvider(ctx context.Context, params *HandshakeFlexibilityProviderParams, body HandshakeFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHandshakeFlexibilityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HandshakeAcknowledgeFlexibilityProviderWithBody(ctx context.Context, params *HandshakeAcknowledgeFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHandshakeAcknowledgeFlexibilityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HandshakeAcknowledgeFlexibilityProvider(ctx context.Context, params *HandshakeAcknowledgeFlexibilityProviderParams, body HandshakeAcknowledgeFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHandshakeAcknowledgeFlexibilityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeartbeatFlexibilityProviderWithBody(ctx context.Context, params *HeartbeatFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeartbeatFlexibilityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeartbeatFlexibilityProvider(ctx context.Context, params *HeartbeatFlexibilityProviderParams, body HeartbeatFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeartbeatFlexibilityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnregisterFlexibilityProviderWithBody(ctx context.Context, params *UnregisterFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnregisterFlexibilityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnregisterFlexibilityProvider(ctx context.Context, params *UnregisterFlexibilityProviderParams, body UnregisterFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnregisterFlexibilityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterFlexibilityProviderWithBody(ctx context.Context, params *RegisterFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterFlexibilityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterFlexibilityProvider(ctx context.Context, params *RegisterFlexibilityProviderParams, body RegisterFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterFlexibilityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRegistrationFlexibilityProviderWithBody(ctx context.Context, params *UpdateRegistrationFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRegistrationFlexibilityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRegistrationFlexibilityProvider(ctx context.Context, params *UpdateRegistrationFlexibilityProviderParams, body UpdateRegistrationFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRegistrationFlexibilityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupCapacityForecastFlexibilityProviderWithBody(ctx context.Context, params *UpdateGroupCapacityForecastFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupCapacityForecastFlexibilityProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupCapacityForecastFlexibilityProvider(ctx context.Context, params *UpdateGroupCapacityForecastFlexibilityProviderParams, body UpdateGroupCapacityForecastFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupCapacityForecastFlexibilityProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewHandshakeCapacityOptimizerRequest calls the generic HandshakeCapacityOptimizer builder with application/json body
func NewHandshakeCapacityOptimizerRequest(server string, params *HandshakeCapacityOptimizerParams, body HandshakeCapacityOptimizerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewHandshakeCapacityOptimizerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewHandshakeCapacityOptimizerRequestWithBody generates requests for HandshakeCapacityOptimizer with any type of body
func NewHandshakeCapacityOptimizerRequestWithBody(server string, params *HandshakeCapacityOptimizerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/co/2.0/handshake")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewHeartbeatCapacityOptimizerRequest calls the generic HeartbeatCapacityOptimizer builder with application/json body
func NewHeartbeatCapacityOptimizerRequest(server string, params *HeartbeatCapacityOptimizerParams, body HeartbeatCapacityOptimizerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewHeartbeatCapacityOptimizerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewHeartbeatCapacityOptimizerRequestWithBody generates requests for HeartbeatCapacityOptimizer with any type of body
func NewHeartbeatCapacityOptimizerRequestWithBody(server string, params *HeartbeatCapacityOptimizerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/co/2.0/heartbeat")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewUnregisterCapacityOptimizerRequest calls the generic UnregisterCapacityOptimizer builder with application/json body
func NewUnregisterCapacityOptimizerRequest(server string, params *UnregisterCapacityOptimizerParams, body UnregisterCapacityOptimizerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnregisterCapacityOptimizerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUnregisterCapacityOptimizerRequestWithBody generates requests for UnregisterCapacityOptimizer with any type of body
func NewUnregisterCapacityOptimizerRequestWithBody(server string, params *UnregisterCapacityOptimizerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/co/2.0/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewRegisterCapacityOptimizerRequest calls the generic RegisterCapacityOptimizer builder with application/json body
func NewRegisterCapacityOptimizerRequest(server string, params *RegisterCapacityOptimizerParams, body RegisterCapacityOptimizerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterCapacityOptimizerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewRegisterCapacityOptimizerRequestWithBody generates requests for RegisterCapacityOptimizer with any type of body
func NewRegisterCapacityOptimizerRequestWithBody(server string, params *RegisterCapacityOptimizerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/co/2.0/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewUpdateRegistrationCapacityOptimizerRequest calls the generic UpdateRegistrationCapacityOptimizer builder with application/json body
func NewUpdateRegistrationCapacityOptimizerRequest(server string, params *UpdateRegistrationCapacityOptimizerParams, body UpdateRegistrationCapacityOptimizerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRegistrationCapacityOptimizerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateRegistrationCapacityOptimizerRequestWithBody generates requests for UpdateRegistrationCapacityOptimizer with any type of body
func NewUpdateRegistrationCapacityOptimizerRequestWithBody(server string, params *UpdateRegistrationCapacityOptimizerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/co/2.0/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewUpdateAssetMeasurementsCapacityOptimizerRequest calls the generic UpdateAssetMeasurementsCapacityOptimizer builder with application/json body
func NewUpdateAssetMeasurementsCapacityOptimizerRequest(server string, params *UpdateAssetMeasurementsCapacityOptimizerParams, body UpdateAssetMeasurementsCapacityOptimizerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAssetMeasurementsCapacityOptimizerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateAssetMeasurementsCapacityOptimizerRequestWithBody generates requests for UpdateAssetMeasurementsCapacityOptimizer with any type of body
func NewUpdateAssetMeasurementsCapacityOptimizerRequestWithBody(server string, params *UpdateAssetMeasurementsCapacityOptimizerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/co/2.0/update_asset_measurements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewUpdateGroupCapacityForecastCapacityOptimizerRequest calls the generic UpdateGroupCapacityForecastCapacityOptimizer builder with application/json body
func NewUpdateGroupCapacityForecastCapacityOptimizerRequest(server string, params *UpdateGroupCapacityForecastCapacityOptimizerParams, body UpdateGroupCapacityForecastCapacityOptimizerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGroupCapacityForecastCapacityOptimizerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateGroupCapacityForecastCapacityOptimizerRequestWithBody generates requests for UpdateGroupCapacityForecastCapacityOptimizer with any type of body
func NewUpdateGroupCapacityForecastCapacityOptimizerRequestWithBody(server string, params *UpdateGroupCapacityForecastCapacityOptimizerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/co/2.0/update_group_capacity_forecast")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewAdjustGroupCapacityForecastCapacityProviderRequest calls the generic AdjustGroupCapacityForecastCapacityProvider builder with application/json body
func NewAdjustGroupCapacityForecastCapacityProviderRequest(server string, params *AdjustGroupCapacityForecastCapacityProviderParams, body AdjustGroupCapacityForecastCapacityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAdjustGroupCapacityForecastCapacityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAdjustGroupCapacityForecastCapacityProviderRequestWithBody generates requests for AdjustGroupCapacityForecastCapacityProvider with any type of body
func NewAdjustGroupCapacityForecastCapacityProviderRequestWithBody(server string, params *AdjustGroupCapacityForecastCapacityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/cp/2.0/adjust_group_capacity_forecast")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewGroupCapacityComplianceErrorCapacityProviderRequest calls the generic GroupCapacityComplianceErrorCapacityProvider builder with application/json body
func NewGroupCapacityComplianceErrorCapacityProviderRequest(server string, params *GroupCapacityComplianceErrorCapacityProviderParams, body GroupCapacityComplianceErrorCapacityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupCapacityComplianceErrorCapacityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGroupCapacityComplianceErrorCapacityProviderRequestWithBody generates requests for GroupCapacityComplianceErrorCapacityProvider with any type of body
func NewGroupCapacityComplianceErrorCapacityProviderRequestWithBody(server string, params *GroupCapacityComplianceErrorCapacityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/cp/2.0/group_capacity_compliance_error")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewHandshakeAcknowledgeCapacityProviderRequest calls the generic HandshakeAcknowledgeCapacityProvider builder with application/json body
func NewHandshakeAcknowledgeCapacityProviderRequest(server string, params *HandshakeAcknowledgeCapacityProviderParams, body HandshakeAcknowledgeCapacityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewHandshakeAcknowledgeCapacityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewHandshakeAcknowledgeCapacityProviderRequestWithBody generates requests for HandshakeAcknowledgeCapacityProvider with any type of body
func NewHandshakeAcknowledgeCapacityProviderRequestWithBody(server string, params *HandshakeAcknowledgeCapacityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/cp/2.0/handshake_acknowledge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewHeartbeatCapacityProviderRequest calls the generic HeartbeatCapacityProvider builder with application/json body
func NewHeartbeatCapacityProviderRequest(server string, params *HeartbeatCapacityProviderParams, body HeartbeatCapacityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewHeartbeatCapacityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewHeartbeatCapacityProviderRequestWithBody generates requests for HeartbeatCapacityProvider with any type of body
func NewHeartbeatCapacityProviderRequestWithBody(server string, params *HeartbeatCapacityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/cp/2.0/heartbeat")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewUnregisterCapacityProviderRequest calls the generic UnregisterCapacityProvider builder with application/json body
func NewUnregisterCapacityProviderRequest(server string, params *UnregisterCapacityProviderParams, body UnregisterCapacityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnregisterCapacityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUnregisterCapacityProviderRequestWithBody generates requests for UnregisterCapacityProvider with any type of body
func NewUnregisterCapacityProviderRequestWithBody(server string, params *UnregisterCapacityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/cp/2.0/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewRegisterCapacityProviderRequest calls the generic RegisterCapacityProvider builder with application/json body
func NewRegisterCapacityProviderRequest(server string, params *RegisterCapacityProviderParams, body RegisterCapacityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterCapacityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewRegisterCapacityProviderRequestWithBody generates requests for RegisterCapacityProvider with any type of body
func NewRegisterCapacityProviderRequestWithBody(server string, params *RegisterCapacityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/cp/2.0/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewUpdateRegistrationCapacityProviderRequest calls the generic UpdateRegistrationCapacityProvider builder with application/json body
func NewUpdateRegistrationCapacityProviderRequest(server string, params *UpdateRegistrationCapacityProviderParams, body UpdateRegistrationCapacityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRegistrationCapacityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateRegistrationCapacityProviderRequestWithBody generates requests for UpdateRegistrationCapacityProvider with any type of body
func NewUpdateRegistrationCapacityProviderRequestWithBody(server string, params *UpdateRegistrationCapacityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/cp/2.0/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewUpdateGroupMeasurementsCapacityProviderRequest calls the generic UpdateGroupMeasurementsCapacityProvider builder with application/json body
func NewUpdateGroupMeasurementsCapacityProviderRequest(server string, params *UpdateGroupMeasurementsCapacityProviderParams, body UpdateGroupMeasurementsCapacityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGroupMeasurementsCapacityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateGroupMeasurementsCapacityProviderRequestWithBody generates requests for UpdateGroupMeasurementsCapacityProvider with any type of body
func NewUpdateGroupMeasurementsCapacityProviderRequestWithBody(server string, params *UpdateGroupMeasurementsCapacityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/cp/2.0/update_group_measurements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewHandshakeFlexibilityProviderRequest calls the generic HandshakeFlexibilityProvider builder with application/json body
func NewHandshakeFlexibilityProviderRequest(server string, params *HandshakeFlexibilityProviderParams, body HandshakeFlexibilityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewHandshakeFlexibilityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewHandshakeFlexibilityProviderRequestWithBody generates requests for HandshakeFlexibilityProvider with any type of body
func NewHandshakeFlexibilityProviderRequestWithBody(server string, params *HandshakeFlexibilityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/fp/2.0/handshake")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewHandshakeAcknowledgeFlexibilityProviderRequest calls the generic HandshakeAcknowledgeFlexibilityProvider builder with application/json body
func NewHandshakeAcknowledgeFlexibilityProviderRequest(server string, params *HandshakeAcknowledgeFlexibilityProviderParams, body HandshakeAcknowledgeFlexibilityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewHandshakeAcknowledgeFlexibilityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewHandshakeAcknowledgeFlexibilityProviderRequestWithBody generates requests for HandshakeAcknowledgeFlexibilityProvider with any type of body
func NewHandshakeAcknowledgeFlexibilityProviderRequestWithBody(server string, params *HandshakeAcknowledgeFlexibilityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/fp/2.0/handshake_acknowledge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewHeartbeatFlexibilityProviderRequest calls the generic HeartbeatFlexibilityProvider builder with application/json body
func NewHeartbeatFlexibilityProviderRequest(server string, params *HeartbeatFlexibilityProviderParams, body HeartbeatFlexibilityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewHeartbeatFlexibilityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewHeartbeatFlexibilityProviderRequestWithBody generates requests for HeartbeatFlexibilityProvider with any type of body
func NewHeartbeatFlexibilityProviderRequestWithBody(server string, params *HeartbeatFlexibilityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/fp/2.0/heartbeat")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewUnregisterFlexibilityProviderRequest calls the generic UnregisterFlexibilityProvider builder with application/json body
func NewUnregisterFlexibilityProviderRequest(server string, params *UnregisterFlexibilityProviderParams, body UnregisterFlexibilityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnregisterFlexibilityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUnregisterFlexibilityProviderRequestWithBody generates requests for UnregisterFlexibilityProvider with any type of body
func NewUnregisterFlexibilityProviderRequestWithBody(server string, params *UnregisterFlexibilityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/fp/2.0/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewRegisterFlexibilityProviderRequest calls the generic RegisterFlexibilityProvider builder with application/json body
func NewRegisterFlexibilityProviderRequest(server string, params *RegisterFlexibilityProviderParams, body RegisterFlexibilityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterFlexibilityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewRegisterFlexibilityProviderRequestWithBody generates requests for RegisterFlexibilityProvider with any type of body
func NewRegisterFlexibilityProviderRequestWithBody(server string, params *RegisterFlexibilityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/fp/2.0/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewUpdateRegistrationFlexibilityProviderRequest calls the generic UpdateRegistrationFlexibilityProvider builder with application/json body
func NewUpdateRegistrationFlexibilityProviderRequest(server string, params *UpdateRegistrationFlexibilityProviderParams, body UpdateRegistrationFlexibilityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRegistrationFlexibilityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateRegistrationFlexibilityProviderRequestWithBody generates requests for UpdateRegistrationFlexibilityProvider with any type of body
func NewUpdateRegistrationFlexibilityProviderRequestWithBody(server string, params *UpdateRegistrationFlexibilityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/fp/2.0/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

// NewUpdateGroupCapacityForecastFlexibilityProviderRequest calls the generic UpdateGroupCapacityForecastFlexibilityProvider builder with application/json body
func NewUpdateGroupCapacityForecastFlexibilityProviderRequest(server string, params *UpdateGroupCapacityForecastFlexibilityProviderParams, body UpdateGroupCapacityForecastFlexibilityProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGroupCapacityForecastFlexibilityProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateGroupCapacityForecastFlexibilityProviderRequestWithBody generates requests for UpdateGroupCapacityForecastFlexibilityProvider with any type of body
func NewUpdateGroupCapacityForecastFlexibilityProviderRequestWithBody(server string, params *UpdateGroupCapacityForecastFlexibilityProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oscp/fp/2.0/update_group_capacity_forecast")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Authorization", headerParam0)

		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, params.XRequestID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Request-ID", headerParam1)

		if params.XCorrelationID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Correlation-ID", runtime.ParamLocationHeader, *params.XCorrelationID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Correlation-ID", headerParam2)
		}

		if params.XSegmentIndex != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Index", runtime.ParamLocationHeader, *params.XSegmentIndex)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Index", headerParam3)
		}

		if params.XSegmentCount != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Segment-Count", runtime.ParamLocationHeader, *params.XSegmentCount)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Segment-Count", headerParam4)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// HandshakeCapacityOptimizerWithBodyWithResponse request with any body
	HandshakeCapacityOptimizerWithBodyWithResponse(ctx context.Context, params *HandshakeCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HandshakeCapacityOptimizerResponse, error)

	HandshakeCapacityOptimizerWithResponse(ctx context.Context, params *HandshakeCapacityOptimizerParams, body HandshakeCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*HandshakeCapacityOptimizerResponse, error)

	// HeartbeatCapacityOptimizerWithBodyWithResponse request with any body
	HeartbeatCapacityOptimizerWithBodyWithResponse(ctx context.Context, params *HeartbeatCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HeartbeatCapacityOptimizerResponse, error)

	HeartbeatCapacityOptimizerWithResponse(ctx context.Context, params *HeartbeatCapacityOptimizerParams, body HeartbeatCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*HeartbeatCapacityOptimizerResponse, error)

	// UnregisterCapacityOptimizerWithBodyWithResponse request with any body
	UnregisterCapacityOptimizerWithBodyWithResponse(ctx context.Context, params *UnregisterCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnregisterCapacityOptimizerResponse, error)

	UnregisterCapacityOptimizerWithResponse(ctx context.Context, params *UnregisterCapacityOptimizerParams, body UnregisterCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*UnregisterCapacityOptimizerResponse, error)

	// RegisterCapacityOptimizerWithBodyWithResponse request with any body
	RegisterCapacityOptimizerWithBodyWithResponse(ctx context.Context, params *RegisterCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterCapacityOptimizerResponse, error)

	RegisterCapacityOptimizerWithResponse(ctx context.Context, params *RegisterCapacityOptimizerParams, body RegisterCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterCapacityOptimizerResponse, error)

	// UpdateRegistrationCapacityOptimizerWithBodyWithResponse request with any body
	UpdateRegistrationCapacityOptimizerWithBodyWithResponse(ctx context.Context, params *UpdateRegistrationCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRegistrationCapacityOptimizerResponse, error)

	UpdateRegistrationCapacityOptimizerWithResponse(ctx context.Context, params *UpdateRegistrationCapacityOptimizerParams, body UpdateRegistrationCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegistrationCapacityOptimizerResponse, error)

	// UpdateAssetMeasurementsCapacityOptimizerWithBodyWithResponse request with any body
	UpdateAssetMeasurementsCapacityOptimizerWithBodyWithResponse(ctx context.Context, params *UpdateAssetMeasurementsCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetMeasurementsCapacityOptimizerResponse, error)

	UpdateAssetMeasurementsCapacityOptimizerWithResponse(ctx context.Context, params *UpdateAssetMeasurementsCapacityOptimizerParams, body UpdateAssetMeasurementsCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetMeasurementsCapacityOptimizerResponse, error)

	// UpdateGroupCapacityForecastCapacityOptimizerWithBodyWithResponse request with any body
	UpdateGroupCapacityForecastCapacityOptimizerWithBodyWithResponse(ctx context.Context, params *UpdateGroupCapacityForecastCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupCapacityForecastCapacityOptimizerResponse, error)

	UpdateGroupCapacityForecastCapacityOptimizerWithResponse(ctx context.Context, params *UpdateGroupCapacityForecastCapacityOptimizerParams, body UpdateGroupCapacityForecastCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupCapacityForecastCapacityOptimizerResponse, error)

	// AdjustGroupCapacityForecastCapacityProviderWithBodyWithResponse request with any body
	AdjustGroupCapacityForecastCapacityProviderWithBodyWithResponse(ctx context.Context, params *AdjustGroupCapacityForecastCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdjustGroupCapacityForecastCapacityProviderResponse, error)

	AdjustGroupCapacityForecastCapacityProviderWithResponse(ctx context.Context, params *AdjustGroupCapacityForecastCapacityProviderParams, body AdjustGroupCapacityForecastCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*AdjustGroupCapacityForecastCapacityProviderResponse, error)

	// GroupCapacityComplianceErrorCapacityProviderWithBodyWithResponse request with any body
	GroupCapacityComplianceErrorCapacityProviderWithBodyWithResponse(ctx context.Context, params *GroupCapacityComplianceErrorCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupCapacityComplianceErrorCapacityProviderResponse, error)

	GroupCapacityComplianceErrorCapacityProviderWithResponse(ctx context.Context, params *GroupCapacityComplianceErrorCapacityProviderParams, body GroupCapacityComplianceErrorCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupCapacityComplianceErrorCapacityProviderResponse, error)

	// HandshakeAcknowledgeCapacityProviderWithBodyWithResponse request with any body
	HandshakeAcknowledgeCapacityProviderWithBodyWithResponse(ctx context.Context, params *HandshakeAcknowledgeCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HandshakeAcknowledgeCapacityProviderResponse, error)

	HandshakeAcknowledgeCapacityProviderWithResponse(ctx context.Context, params *HandshakeAcknowledgeCapacityProviderParams, body HandshakeAcknowledgeCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*HandshakeAcknowledgeCapacityProviderResponse, error)

	// HeartbeatCapacityProviderWithBodyWithResponse request with any body
	HeartbeatCapacityProviderWithBodyWithResponse(ctx context.Context, params *HeartbeatCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HeartbeatCapacityProviderResponse, error)

	HeartbeatCapacityProviderWithResponse(ctx context.Context, params *HeartbeatCapacityProviderParams, body HeartbeatCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*HeartbeatCapacityProviderResponse, error)

	// UnregisterCapacityProviderWithBodyWithResponse request with any body
	UnregisterCapacityProviderWithBodyWithResponse(ctx context.Context, params *UnregisterCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnregisterCapacityProviderResponse, error)

	UnregisterCapacityProviderWithResponse(ctx context.Context, params *UnregisterCapacityProviderParams, body UnregisterCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UnregisterCapacityProviderResponse, error)

	// RegisterCapacityProviderWithBodyWithResponse request with any body
	RegisterCapacityProviderWithBodyWithResponse(ctx context.Context, params *RegisterCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterCapacityProviderResponse, error)

	RegisterCapacityProviderWithResponse(ctx context.Context, params *RegisterCapacityProviderParams, body RegisterCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterCapacityProviderResponse, error)

	// UpdateRegistrationCapacityProviderWithBodyWithResponse request with any body
	UpdateRegistrationCapacityProviderWithBodyWithResponse(ctx context.Context, params *UpdateRegistrationCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRegistrationCapacityProviderResponse, error)

	UpdateRegistrationCapacityProviderWithResponse(ctx context.Context, params *UpdateRegistrationCapacityProviderParams, body UpdateRegistrationCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegistrationCapacityProviderResponse, error)

	// UpdateGroupMeasurementsCapacityProviderWithBodyWithResponse request with any body
	UpdateGroupMeasurementsCapacityProviderWithBodyWithResponse(ctx context.Context, params *UpdateGroupMeasurementsCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupMeasurementsCapacityProviderResponse, error)

	UpdateGroupMeasurementsCapacityProviderWithResponse(ctx context.Context, params *UpdateGroupMeasurementsCapacityProviderParams, body UpdateGroupMeasurementsCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupMeasurementsCapacityProviderResponse, error)

	// HandshakeFlexibilityProviderWithBodyWithResponse request with any body
	HandshakeFlexibilityProviderWithBodyWithResponse(ctx context.Context, params *HandshakeFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HandshakeFlexibilityProviderResponse, error)

	HandshakeFlexibilityProviderWithResponse(ctx context.Context, params *HandshakeFlexibilityProviderParams, body HandshakeFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*HandshakeFlexibilityProviderResponse, error)

	// HandshakeAcknowledgeFlexibilityProviderWithBodyWithResponse request with any body
	HandshakeAcknowledgeFlexibilityProviderWithBodyWithResponse(ctx context.Context, params *HandshakeAcknowledgeFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HandshakeAcknowledgeFlexibilityProviderResponse, error)

	HandshakeAcknowledgeFlexibilityProviderWithResponse(ctx context.Context, params *HandshakeAcknowledgeFlexibilityProviderParams, body HandshakeAcknowledgeFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*HandshakeAcknowledgeFlexibilityProviderResponse, error)

	// HeartbeatFlexibilityProviderWithBodyWithResponse request with any body
	HeartbeatFlexibilityProviderWithBodyWithResponse(ctx context.Context, params *HeartbeatFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HeartbeatFlexibilityProviderResponse, error)

	HeartbeatFlexibilityProviderWithResponse(ctx context.Context, params *HeartbeatFlexibilityProviderParams, body HeartbeatFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*HeartbeatFlexibilityProviderResponse, error)

	// UnregisterFlexibilityProviderWithBodyWithResponse request with any body
	UnregisterFlexibilityProviderWithBodyWithResponse(ctx context.Context, params *UnregisterFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnregisterFlexibilityProviderResponse, error)

	UnregisterFlexibilityProviderWithResponse(ctx context.Context, params *UnregisterFlexibilityProviderParams, body UnregisterFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UnregisterFlexibilityProviderResponse, error)

	// RegisterFlexibilityProviderWithBodyWithResponse request with any body
	RegisterFlexibilityProviderWithBodyWithResponse(ctx context.Context, params *RegisterFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterFlexibilityProviderResponse, error)

	RegisterFlexibilityProviderWithResponse(ctx context.Context, params *RegisterFlexibilityProviderParams, body RegisterFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterFlexibilityProviderResponse, error)

	// UpdateRegistrationFlexibilityProviderWithBodyWithResponse request with any body
	UpdateRegistrationFlexibilityProviderWithBodyWithResponse(ctx context.Context, params *UpdateRegistrationFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlexibilityProviderResponse, error)

	UpdateRegistrationFlexibilityProviderWithResponse(ctx context.Context, params *UpdateRegistrationFlexibilityProviderParams, body UpdateRegistrationFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlexibilityProviderResponse, error)

	// UpdateGroupCapacityForecastFlexibilityProviderWithBodyWithResponse request with any body
	UpdateGroupCapacityForecastFlexibilityProviderWithBodyWithResponse(ctx context.Context, params *UpdateGroupCapacityForecastFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupCapacityForecastFlexibilityProviderResponse, error)

	UpdateGroupCapacityForecastFlexibilityProviderWithResponse(ctx context.Context, params *UpdateGroupCapacityForecastFlexibilityProviderParams, body UpdateGroupCapacityForecastFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupCapacityForecastFlexibilityProviderResponse, error)
}

type HandshakeCapacityOptimizerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r HandshakeCapacityOptimizerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HandshakeCapacityOptimizerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeartbeatCapacityOptimizerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r HeartbeatCapacityOptimizerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeartbeatCapacityOptimizerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnregisterCapacityOptimizerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r UnregisterCapacityOptimizerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnregisterCapacityOptimizerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterCapacityOptimizerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r RegisterCapacityOptimizerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterCapacityOptimizerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRegistrationCapacityOptimizerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r UpdateRegistrationCapacityOptimizerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRegistrationCapacityOptimizerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAssetMeasurementsCapacityOptimizerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
	JSON501      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r UpdateAssetMeasurementsCapacityOptimizerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAssetMeasurementsCapacityOptimizerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGroupCapacityForecastCapacityOptimizerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r UpdateGroupCapacityForecastCapacityOptimizerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGroupCapacityForecastCapacityOptimizerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdjustGroupCapacityForecastCapacityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r AdjustGroupCapacityForecastCapacityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdjustGroupCapacityForecastCapacityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupCapacityComplianceErrorCapacityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r GroupCapacityComplianceErrorCapacityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupCapacityComplianceErrorCapacityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HandshakeAcknowledgeCapacityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r HandshakeAcknowledgeCapacityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HandshakeAcknowledgeCapacityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeartbeatCapacityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r HeartbeatCapacityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeartbeatCapacityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnregisterCapacityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r UnregisterCapacityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnregisterCapacityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterCapacityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r RegisterCapacityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterCapacityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRegistrationCapacityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r UpdateRegistrationCapacityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRegistrationCapacityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGroupMeasurementsCapacityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
	JSON501      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r UpdateGroupMeasurementsCapacityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGroupMeasurementsCapacityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HandshakeFlexibilityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r HandshakeFlexibilityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HandshakeFlexibilityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HandshakeAcknowledgeFlexibilityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r HandshakeAcknowledgeFlexibilityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HandshakeAcknowledgeFlexibilityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeartbeatFlexibilityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r HeartbeatFlexibilityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeartbeatFlexibilityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnregisterFlexibilityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r UnregisterFlexibilityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnregisterFlexibilityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterFlexibilityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r RegisterFlexibilityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterFlexibilityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRegistrationFlexibilityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r UpdateRegistrationFlexibilityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRegistrationFlexibilityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGroupCapacityForecastFlexibilityProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorBody
	JSON404      *ErrorBody
	JSON500      *ErrorBody
}

// Status returns HTTPResponse.Status
func (r UpdateGroupCapacityForecastFlexibilityProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGroupCapacityForecastFlexibilityProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// HandshakeCapacityOptimizerWithBodyWithResponse request with arbitrary body returning *HandshakeCapacityOptimizerResponse
func (c *ClientWithResponses) HandshakeCapacityOptimizerWithBodyWithResponse(ctx context.Context, params *HandshakeCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HandshakeCapacityOptimizerResponse, error) {
	rsp, err := c.HandshakeCapacityOptimizerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHandshakeCapacityOptimizerResponse(rsp)
}

func (c *ClientWithResponses) HandshakeCapacityOptimizerWithResponse(ctx context.Context, params *HandshakeCapacityOptimizerParams, body HandshakeCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*HandshakeCapacityOptimizerResponse, error) {
	rsp, err := c.HandshakeCapacityOptimizer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHandshakeCapacityOptimizerResponse(rsp)
}

// HeartbeatCapacityOptimizerWithBodyWithResponse request with arbitrary body returning *HeartbeatCapacityOptimizerResponse
func (c *ClientWithResponses) HeartbeatCapacityOptimizerWithBodyWithResponse(ctx context.Context, params *HeartbeatCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HeartbeatCapacityOptimizerResponse, error) {
	rsp, err := c.HeartbeatCapacityOptimizerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeartbeatCapacityOptimizerResponse(rsp)
}

func (c *ClientWithResponses) HeartbeatCapacityOptimizerWithResponse(ctx context.Context, params *HeartbeatCapacityOptimizerParams, body HeartbeatCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*HeartbeatCapacityOptimizerResponse, error) {
	rsp, err := c.HeartbeatCapacityOptimizer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeartbeatCapacityOptimizerResponse(rsp)
}

// UnregisterCapacityOptimizerWithBodyWithResponse request with arbitrary body returning *UnregisterCapacityOptimizerResponse
func (c *ClientWithResponses) UnregisterCapacityOptimizerWithBodyWithResponse(ctx context.Context, params *UnregisterCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnregisterCapacityOptimizerResponse, error) {
	rsp, err := c.UnregisterCapacityOptimizerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnregisterCapacityOptimizerResponse(rsp)
}

func (c *ClientWithResponses) UnregisterCapacityOptimizerWithResponse(ctx context.Context, params *UnregisterCapacityOptimizerParams, body UnregisterCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*UnregisterCapacityOptimizerResponse, error) {
	rsp, err := c.UnregisterCapacityOptimizer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnregisterCapacityOptimizerResponse(rsp)
}

// RegisterCapacityOptimizerWithBodyWithResponse request with arbitrary body returning *RegisterCapacityOptimizerResponse
func (c *ClientWithResponses) RegisterCapacityOptimizerWithBodyWithResponse(ctx context.Context, params *RegisterCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterCapacityOptimizerResponse, error) {
	rsp, err := c.RegisterCapacityOptimizerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterCapacityOptimizerResponse(rsp)
}

func (c *ClientWithResponses) RegisterCapacityOptimizerWithResponse(ctx context.Context, params *RegisterCapacityOptimizerParams, body RegisterCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterCapacityOptimizerResponse, error) {
	rsp, err := c.RegisterCapacityOptimizer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterCapacityOptimizerResponse(rsp)
}

// UpdateRegistrationCapacityOptimizerWithBodyWithResponse request with arbitrary body returning *UpdateRegistrationCapacityOptimizerResponse
func (c *ClientWithResponses) UpdateRegistrationCapacityOptimizerWithBodyWithResponse(ctx context.Context, params *UpdateRegistrationCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRegistrationCapacityOptimizerResponse, error) {
	rsp, err := c.UpdateRegistrationCapacityOptimizerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRegistrationCapacityOptimizerResponse(rsp)
}

func (c *ClientWithResponses) UpdateRegistrationCapacityOptimizerWithResponse(ctx context.Context, params *UpdateRegistrationCapacityOptimizerParams, body UpdateRegistrationCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegistrationCapacityOptimizerResponse, error) {
	rsp, err := c.UpdateRegistrationCapacityOptimizer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRegistrationCapacityOptimizerResponse(rsp)
}

// UpdateAssetMeasurementsCapacityOptimizerWithBodyWithResponse request with arbitrary body returning *UpdateAssetMeasurementsCapacityOptimizerResponse
func (c *ClientWithResponses) UpdateAssetMeasurementsCapacityOptimizerWithBodyWithResponse(ctx context.Context, params *UpdateAssetMeasurementsCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetMeasurementsCapacityOptimizerResponse, error) {
	rsp, err := c.UpdateAssetMeasurementsCapacityOptimizerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetMeasurementsCapacityOptimizerResponse(rsp)
}

func (c *ClientWithResponses) UpdateAssetMeasurementsCapacityOptimizerWithResponse(ctx context.Context, params *UpdateAssetMeasurementsCapacityOptimizerParams, body UpdateAssetMeasurementsCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetMeasurementsCapacityOptimizerResponse, error) {
	rsp, err := c.UpdateAssetMeasurementsCapacityOptimizer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetMeasurementsCapacityOptimizerResponse(rsp)
}

// UpdateGroupCapacityForecastCapacityOptimizerWithBodyWithResponse request with arbitrary body returning *UpdateGroupCapacityForecastCapacityOptimizerResponse
func (c *ClientWithResponses) UpdateGroupCapacityForecastCapacityOptimizerWithBodyWithResponse(ctx context.Context, params *UpdateGroupCapacityForecastCapacityOptimizerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupCapacityForecastCapacityOptimizerResponse, error) {
	rsp, err := c.UpdateGroupCapacityForecastCapacityOptimizerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupCapacityForecastCapacityOptimizerResponse(rsp)
}

func (c *ClientWithResponses) UpdateGroupCapacityForecastCapacityOptimizerWithResponse(ctx context.Context, params *UpdateGroupCapacityForecastCapacityOptimizerParams, body UpdateGroupCapacityForecastCapacityOptimizerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupCapacityForecastCapacityOptimizerResponse, error) {
	rsp, err := c.UpdateGroupCapacityForecastCapacityOptimizer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupCapacityForecastCapacityOptimizerResponse(rsp)
}

// AdjustGroupCapacityForecastCapacityProviderWithBodyWithResponse request with arbitrary body returning *AdjustGroupCapacityForecastCapacityProviderResponse
func (c *ClientWithResponses) AdjustGroupCapacityForecastCapacityProviderWithBodyWithResponse(ctx context.Context, params *AdjustGroupCapacityForecastCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdjustGroupCapacityForecastCapacityProviderResponse, error) {
	rsp, err := c.AdjustGroupCapacityForecastCapacityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdjustGroupCapacityForecastCapacityProviderResponse(rsp)
}

func (c *ClientWithResponses) AdjustGroupCapacityForecastCapacityProviderWithResponse(ctx context.Context, params *AdjustGroupCapacityForecastCapacityProviderParams, body AdjustGroupCapacityForecastCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*AdjustGroupCapacityForecastCapacityProviderResponse, error) {
	rsp, err := c.AdjustGroupCapacityForecastCapacityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdjustGroupCapacityForecastCapacityProviderResponse(rsp)
}

// GroupCapacityComplianceErrorCapacityProviderWithBodyWithResponse request with arbitrary body returning *GroupCapacityComplianceErrorCapacityProviderResponse
func (c *ClientWithResponses) GroupCapacityComplianceErrorCapacityProviderWithBodyWithResponse(ctx context.Context, params *GroupCapacityComplianceErrorCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupCapacityComplianceErrorCapacityProviderResponse, error) {
	rsp, err := c.GroupCapacityComplianceErrorCapacityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupCapacityComplianceErrorCapacityProviderResponse(rsp)
}

func (c *ClientWithResponses) GroupCapacityComplianceErrorCapacityProviderWithResponse(ctx context.Context, params *GroupCapacityComplianceErrorCapacityProviderParams, body GroupCapacityComplianceErrorCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupCapacityComplianceErrorCapacityProviderResponse, error) {
	rsp, err := c.GroupCapacityComplianceErrorCapacityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupCapacityComplianceErrorCapacityProviderResponse(rsp)
}

// HandshakeAcknowledgeCapacityProviderWithBodyWithResponse request with arbitrary body returning *HandshakeAcknowledgeCapacityProviderResponse
func (c *ClientWithResponses) HandshakeAcknowledgeCapacityProviderWithBodyWithResponse(ctx context.Context, params *HandshakeAcknowledgeCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HandshakeAcknowledgeCapacityProviderResponse, error) {
	rsp, err := c.HandshakeAcknowledgeCapacityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHandshakeAcknowledgeCapacityProviderResponse(rsp)
}

func (c *ClientWithResponses) HandshakeAcknowledgeCapacityProviderWithResponse(ctx context.Context, params *HandshakeAcknowledgeCapacityProviderParams, body HandshakeAcknowledgeCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*HandshakeAcknowledgeCapacityProviderResponse, error) {
	rsp, err := c.HandshakeAcknowledgeCapacityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHandshakeAcknowledgeCapacityProviderResponse(rsp)
}

// HeartbeatCapacityProviderWithBodyWithResponse request with arbitrary body returning *HeartbeatCapacityProviderResponse
func (c *ClientWithResponses) HeartbeatCapacityProviderWithBodyWithResponse(ctx context.Context, params *HeartbeatCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HeartbeatCapacityProviderResponse, error) {
	rsp, err := c.HeartbeatCapacityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeartbeatCapacityProviderResponse(rsp)
}

func (c *ClientWithResponses) HeartbeatCapacityProviderWithResponse(ctx context.Context, params *HeartbeatCapacityProviderParams, body HeartbeatCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*HeartbeatCapacityProviderResponse, error) {
	rsp, err := c.HeartbeatCapacityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeartbeatCapacityProviderResponse(rsp)
}

// UnregisterCapacityProviderWithBodyWithResponse request with arbitrary body returning *UnregisterCapacityProviderResponse
func (c *ClientWithResponses) UnregisterCapacityProviderWithBodyWithResponse(ctx context.Context, params *UnregisterCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnregisterCapacityProviderResponse, error) {
	rsp, err := c.UnregisterCapacityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnregisterCapacityProviderResponse(rsp)
}

func (c *ClientWithResponses) UnregisterCapacityProviderWithResponse(ctx context.Context, params *UnregisterCapacityProviderParams, body UnregisterCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UnregisterCapacityProviderResponse, error) {
	rsp, err := c.UnregisterCapacityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnregisterCapacityProviderResponse(rsp)
}

// RegisterCapacityProviderWithBodyWithResponse request with arbitrary body returning *RegisterCapacityProviderResponse
func (c *ClientWithResponses) RegisterCapacityProviderWithBodyWithResponse(ctx context.Context, params *RegisterCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterCapacityProviderResponse, error) {
	rsp, err := c.RegisterCapacityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterCapacityProviderResponse(rsp)
}

func (c *ClientWithResponses) RegisterCapacityProviderWithResponse(ctx context.Context, params *RegisterCapacityProviderParams, body RegisterCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterCapacityProviderResponse, error) {
	rsp, err := c.RegisterCapacityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterCapacityProviderResponse(rsp)
}

// UpdateRegistrationCapacityProviderWithBodyWithResponse request with arbitrary body returning *UpdateRegistrationCapacityProviderResponse
func (c *ClientWithResponses) UpdateRegistrationCapacityProviderWithBodyWithResponse(ctx context.Context, params *UpdateRegistrationCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRegistrationCapacityProviderResponse, error) {
	rsp, err := c.UpdateRegistrationCapacityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRegistrationCapacityProviderResponse(rsp)
}

func (c *ClientWithResponses) UpdateRegistrationCapacityProviderWithResponse(ctx context.Context, params *UpdateRegistrationCapacityProviderParams, body UpdateRegistrationCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegistrationCapacityProviderResponse, error) {
	rsp, err := c.UpdateRegistrationCapacityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRegistrationCapacityProviderResponse(rsp)
}

// UpdateGroupMeasurementsCapacityProviderWithBodyWithResponse request with arbitrary body returning *UpdateGroupMeasurementsCapacityProviderResponse
func (c *ClientWithResponses) UpdateGroupMeasurementsCapacityProviderWithBodyWithResponse(ctx context.Context, params *UpdateGroupMeasurementsCapacityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupMeasurementsCapacityProviderResponse, error) {
	rsp, err := c.UpdateGroupMeasurementsCapacityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupMeasurementsCapacityProviderResponse(rsp)
}

func (c *ClientWithResponses) UpdateGroupMeasurementsCapacityProviderWithResponse(ctx context.Context, params *UpdateGroupMeasurementsCapacityProviderParams, body UpdateGroupMeasurementsCapacityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupMeasurementsCapacityProviderResponse, error) {
	rsp, err := c.UpdateGroupMeasurementsCapacityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupMeasurementsCapacityProviderResponse(rsp)
}

// HandshakeFlexibilityProviderWithBodyWithResponse request with arbitrary body returning *HandshakeFlexibilityProviderResponse
func (c *ClientWithResponses) HandshakeFlexibilityProviderWithBodyWithResponse(ctx context.Context, params *HandshakeFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HandshakeFlexibilityProviderResponse, error) {
	rsp, err := c.HandshakeFlexibilityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHandshakeFlexibilityProviderResponse(rsp)
}

func (c *ClientWithResponses) HandshakeFlexibilityProviderWithResponse(ctx context.Context, params *HandshakeFlexibilityProviderParams, body HandshakeFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*HandshakeFlexibilityProviderResponse, error) {
	rsp, err := c.HandshakeFlexibilityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHandshakeFlexibilityProviderResponse(rsp)
}

// HandshakeAcknowledgeFlexibilityProviderWithBodyWithResponse request with arbitrary body returning *HandshakeAcknowledgeFlexibilityProviderResponse
func (c *ClientWithResponses) HandshakeAcknowledgeFlexibilityProviderWithBodyWithResponse(ctx context.Context, params *HandshakeAcknowledgeFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HandshakeAcknowledgeFlexibilityProviderResponse, error) {
	rsp, err := c.HandshakeAcknowledgeFlexibilityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHandshakeAcknowledgeFlexibilityProviderResponse(rsp)
}

func (c *ClientWithResponses) HandshakeAcknowledgeFlexibilityProviderWithResponse(ctx context.Context, params *HandshakeAcknowledgeFlexibilityProviderParams, body HandshakeAcknowledgeFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*HandshakeAcknowledgeFlexibilityProviderResponse, error) {
	rsp, err := c.HandshakeAcknowledgeFlexibilityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHandshakeAcknowledgeFlexibilityProviderResponse(rsp)
}

// HeartbeatFlexibilityProviderWithBodyWithResponse request with arbitrary body returning *HeartbeatFlexibilityProviderResponse
func (c *ClientWithResponses) HeartbeatFlexibilityProviderWithBodyWithResponse(ctx context.Context, params *HeartbeatFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*HeartbeatFlexibilityProviderResponse, error) {
	rsp, err := c.HeartbeatFlexibilityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeartbeatFlexibilityProviderResponse(rsp)
}

func (c *ClientWithResponses) HeartbeatFlexibilityProviderWithResponse(ctx context.Context, params *HeartbeatFlexibilityProviderParams, body HeartbeatFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*HeartbeatFlexibilityProviderResponse, error) {
	rsp, err := c.HeartbeatFlexibilityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeartbeatFlexibilityProviderResponse(rsp)
}

// UnregisterFlexibilityProviderWithBodyWithResponse request with arbitrary body returning *UnregisterFlexibilityProviderResponse
func (c *ClientWithResponses) UnregisterFlexibilityProviderWithBodyWithResponse(ctx context.Context, params *UnregisterFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnregisterFlexibilityProviderResponse, error) {
	rsp, err := c.UnregisterFlexibilityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnregisterFlexibilityProviderResponse(rsp)
}

func (c *ClientWithResponses) UnregisterFlexibilityProviderWithResponse(ctx context.Context, params *UnregisterFlexibilityProviderParams, body UnregisterFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UnregisterFlexibilityProviderResponse, error) {
	rsp, err := c.UnregisterFlexibilityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnregisterFlexibilityProviderResponse(rsp)
}

// RegisterFlexibilityProviderWithBodyWithResponse request with arbitrary body returning *RegisterFlexibilityProviderResponse
func (c *ClientWithResponses) RegisterFlexibilityProviderWithBodyWithResponse(ctx context.Context, params *RegisterFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterFlexibilityProviderResponse, error) {
	rsp, err := c.RegisterFlexibilityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterFlexibilityProviderResponse(rsp)
}

func (c *ClientWithResponses) RegisterFlexibilityProviderWithResponse(ctx context.Context, params *RegisterFlexibilityProviderParams, body RegisterFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterFlexibilityProviderResponse, error) {
	rsp, err := c.RegisterFlexibilityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterFlexibilityProviderResponse(rsp)
}

// UpdateRegistrationFlexibilityProviderWithBodyWithResponse request with arbitrary body returning *UpdateRegistrationFlexibilityProviderResponse
func (c *ClientWithResponses) UpdateRegistrationFlexibilityProviderWithBodyWithResponse(ctx context.Context, params *UpdateRegistrationFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlexibilityProviderResponse, error) {
	rsp, err := c.UpdateRegistrationFlexibilityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRegistrationFlexibilityProviderResponse(rsp)
}

func (c *ClientWithResponses) UpdateRegistrationFlexibilityProviderWithResponse(ctx context.Context, params *UpdateRegistrationFlexibilityProviderParams, body UpdateRegistrationFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegistrationFlexibilityProviderResponse, error) {
	rsp, err := c.UpdateRegistrationFlexibilityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRegistrationFlexibilityProviderResponse(rsp)
}

// UpdateGroupCapacityForecastFlexibilityProviderWithBodyWithResponse request with arbitrary body returning *UpdateGroupCapacityForecastFlexibilityProviderResponse
func (c *ClientWithResponses) UpdateGroupCapacityForecastFlexibilityProviderWithBodyWithResponse(ctx context.Context, params *UpdateGroupCapacityForecastFlexibilityProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupCapacityForecastFlexibilityProviderResponse, error) {
	rsp, err := c.UpdateGroupCapacityForecastFlexibilityProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupCapacityForecastFlexibilityProviderResponse(rsp)
}

func (c *ClientWithResponses) UpdateGroupCapacityForecastFlexibilityProviderWithResponse(ctx context.Context, params *UpdateGroupCapacityForecastFlexibilityProviderParams, body UpdateGroupCapacityForecastFlexibilityProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupCapacityForecastFlexibilityProviderResponse, error) {
	rsp, err := c.UpdateGroupCapacityForecastFlexibilityProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupCapacityForecastFlexibilityProviderResponse(rsp)
}

// ParseHandshakeCapacityOptimizerResponse parses an HTTP response from a HandshakeCapacityOptimizerWithResponse call
func ParseHandshakeCapacityOptimizerResponse(rsp *http.Response) (*HandshakeCapacityOptimizerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HandshakeCapacityOptimizerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseHeartbeatCapacityOptimizerResponse parses an HTTP response from a HeartbeatCapacityOptimizerWithResponse call
func ParseHeartbeatCapacityOptimizerResponse(rsp *http.Response) (*HeartbeatCapacityOptimizerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeartbeatCapacityOptimizerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUnregisterCapacityOptimizerResponse parses an HTTP response from a UnregisterCapacityOptimizerWithResponse call
func ParseUnregisterCapacityOptimizerResponse(rsp *http.Response) (*UnregisterCapacityOptimizerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnregisterCapacityOptimizerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRegisterCapacityOptimizerResponse parses an HTTP response from a RegisterCapacityOptimizerWithResponse call
func ParseRegisterCapacityOptimizerResponse(rsp *http.Response) (*RegisterCapacityOptimizerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterCapacityOptimizerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRegistrationCapacityOptimizerResponse parses an HTTP response from a UpdateRegistrationCapacityOptimizerWithResponse call
func ParseUpdateRegistrationCapacityOptimizerResponse(rsp *http.Response) (*UpdateRegistrationCapacityOptimizerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRegistrationCapacityOptimizerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAssetMeasurementsCapacityOptimizerResponse parses an HTTP response from a UpdateAssetMeasurementsCapacityOptimizerWithResponse call
func ParseUpdateAssetMeasurementsCapacityOptimizerResponse(rsp *http.Response) (*UpdateAssetMeasurementsCapacityOptimizerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAssetMeasurementsCapacityOptimizerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseUpdateGroupCapacityForecastCapacityOptimizerResponse parses an HTTP response from a UpdateGroupCapacityForecastCapacityOptimizerWithResponse call
func ParseUpdateGroupCapacityForecastCapacityOptimizerResponse(rsp *http.Response) (*UpdateGroupCapacityForecastCapacityOptimizerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGroupCapacityForecastCapacityOptimizerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAdjustGroupCapacityForecastCapacityProviderResponse parses an HTTP response from a AdjustGroupCapacityForecastCapacityProviderWithResponse call
func ParseAdjustGroupCapacityForecastCapacityProviderResponse(rsp *http.Response) (*AdjustGroupCapacityForecastCapacityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdjustGroupCapacityForecastCapacityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGroupCapacityComplianceErrorCapacityProviderResponse parses an HTTP response from a GroupCapacityComplianceErrorCapacityProviderWithResponse call
func ParseGroupCapacityComplianceErrorCapacityProviderResponse(rsp *http.Response) (*GroupCapacityComplianceErrorCapacityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupCapacityComplianceErrorCapacityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseHandshakeAcknowledgeCapacityProviderResponse parses an HTTP response from a HandshakeAcknowledgeCapacityProviderWithResponse call
func ParseHandshakeAcknowledgeCapacityProviderResponse(rsp *http.Response) (*HandshakeAcknowledgeCapacityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HandshakeAcknowledgeCapacityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseHeartbeatCapacityProviderResponse parses an HTTP response from a HeartbeatCapacityProviderWithResponse call
func ParseHeartbeatCapacityProviderResponse(rsp *http.Response) (*HeartbeatCapacityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeartbeatCapacityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUnregisterCapacityProviderResponse parses an HTTP response from a UnregisterCapacityProviderWithResponse call
func ParseUnregisterCapacityProviderResponse(rsp *http.Response) (*UnregisterCapacityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnregisterCapacityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRegisterCapacityProviderResponse parses an HTTP response from a RegisterCapacityProviderWithResponse call
func ParseRegisterCapacityProviderResponse(rsp *http.Response) (*RegisterCapacityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterCapacityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRegistrationCapacityProviderResponse parses an HTTP response from a UpdateRegistrationCapacityProviderWithResponse call
func ParseUpdateRegistrationCapacityProviderResponse(rsp *http.Response) (*UpdateRegistrationCapacityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRegistrationCapacityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateGroupMeasurementsCapacityProviderResponse parses an HTTP response from a UpdateGroupMeasurementsCapacityProviderWithResponse call
func ParseUpdateGroupMeasurementsCapacityProviderResponse(rsp *http.Response) (*UpdateGroupMeasurementsCapacityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGroupMeasurementsCapacityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseHandshakeFlexibilityProviderResponse parses an HTTP response from a HandshakeFlexibilityProviderWithResponse call
func ParseHandshakeFlexibilityProviderResponse(rsp *http.Response) (*HandshakeFlexibilityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HandshakeFlexibilityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseHandshakeAcknowledgeFlexibilityProviderResponse parses an HTTP response from a HandshakeAcknowledgeFlexibilityProviderWithResponse call
func ParseHandshakeAcknowledgeFlexibilityProviderResponse(rsp *http.Response) (*HandshakeAcknowledgeFlexibilityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HandshakeAcknowledgeFlexibilityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseHeartbeatFlexibilityProviderResponse parses an HTTP response from a HeartbeatFlexibilityProviderWithResponse call
func ParseHeartbeatFlexibilityProviderResponse(rsp *http.Response) (*HeartbeatFlexibilityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeartbeatFlexibilityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUnregisterFlexibilityProviderResponse parses an HTTP response from a UnregisterFlexibilityProviderWithResponse call
func ParseUnregisterFlexibilityProviderResponse(rsp *http.Response) (*UnregisterFlexibilityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnregisterFlexibilityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRegisterFlexibilityProviderResponse parses an HTTP response from a RegisterFlexibilityProviderWithResponse call
func ParseRegisterFlexibilityProviderResponse(rsp *http.Response) (*RegisterFlexibilityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterFlexibilityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRegistrationFlexibilityProviderResponse parses an HTTP response from a UpdateRegistrationFlexibilityProviderWithResponse call
func ParseUpdateRegistrationFlexibilityProviderResponse(rsp *http.Response) (*UpdateRegistrationFlexibilityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRegistrationFlexibilityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateGroupCapacityForecastFlexibilityProviderResponse parses an HTTP response from a UpdateGroupCapacityForecastFlexibilityProviderWithResponse call
func ParseUpdateGroupCapacityForecastFlexibilityProviderResponse(rsp *http.Response) (*UpdateGroupCapacityForecastFlexibilityProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGroupCapacityForecastFlexibilityProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
