// Package oscp_v20 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.0 DO NOT EDIT.
package oscp_v20

import (
	"fmt"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for AssetCategory.
const (
	AssetCategoryCHARGING    AssetCategory = "CHARGING"
	AssetCategoryCONSUMPTION AssetCategory = "CONSUMPTION"
	AssetCategoryGENERATION  AssetCategory = "GENERATION"
	AssetCategorySTORAGE     AssetCategory = "STORAGE"
)

// Defines values for CapacityForecastType.
const (
	CapacityForecastTypeCONSUMPTION         CapacityForecastType = "CONSUMPTION"
	CapacityForecastTypeFALLBACKCONSUMPTION CapacityForecastType = "FALLBACK_CONSUMPTION"
	CapacityForecastTypeFALLBACKGENERATION  CapacityForecastType = "FALLBACK_GENERATION"
	CapacityForecastTypeGENERATION          CapacityForecastType = "GENERATION"
	CapacityForecastTypeOPTIMUM             CapacityForecastType = "OPTIMUM"
)

// Defines values for EnergyFlowDirection.
const (
	EXPORT EnergyFlowDirection = "EXPORT"
	IMPORT EnergyFlowDirection = "IMPORT"
	NET    EnergyFlowDirection = "NET"
)

// Defines values for EnergyMeasurementUnit.
const (
	EnergyMeasurementUnitKWH EnergyMeasurementUnit = "KWH"
	EnergyMeasurementUnitWH  EnergyMeasurementUnit = "WH"
)

// Defines values for EnergyType.
const (
	FLEXIBLE    EnergyType = "FLEXIBLE"
	NONFLEXIBLE EnergyType = "NONFLEXIBLE"
	TOTAL       EnergyType = "TOTAL"
)

// Defines values for ForecastedBlockUnit.
const (
	ForecastedBlockUnitA   ForecastedBlockUnit = "A"
	ForecastedBlockUnitKW  ForecastedBlockUnit = "KW"
	ForecastedBlockUnitKWH ForecastedBlockUnit = "KWH"
	ForecastedBlockUnitW   ForecastedBlockUnit = "W"
	ForecastedBlockUnitWH  ForecastedBlockUnit = "WH"
)

// Defines values for InstantaneousMeasurementUnit.
const (
	A   InstantaneousMeasurementUnit = "A"
	KW  InstantaneousMeasurementUnit = "KW"
	KWH InstantaneousMeasurementUnit = "KWH"
	W   InstantaneousMeasurementUnit = "W"
	WH  InstantaneousMeasurementUnit = "WH"
)

// Defines values for MeasurementConfiguration.
const (
	CONTINUOUS   MeasurementConfiguration = "CONTINUOUS"
	INTERMITTENT MeasurementConfiguration = "INTERMITTENT"
)

// Defines values for PhaseIndicator.
const (
	ALL     PhaseIndicator = "ALL"
	ONE     PhaseIndicator = "ONE"
	THREE   PhaseIndicator = "THREE"
	TWO     PhaseIndicator = "TWO"
	UNKNOWN PhaseIndicator = "UNKNOWN"
)

// AssetCategory defines model for AssetCategory.
type AssetCategory string

// AssetMeasurement defines model for AssetMeasurement.
type AssetMeasurement struct {
	AssetCategory            string                    `json:"asset_category"`
	AssetId                  string                    `json:"asset_id"`
	EnergyMeasurement        *EnergyMeasurement        `json:"energy_measurement,omitempty"`
	InstantaneousMeasurement *InstantaneousMeasurement `json:"instantaneous_measurement,omitempty"`
}

// CapacityForecastType defines model for CapacityForecastType.
type CapacityForecastType string

// EnergyFlowDirection defines model for EnergyFlowDirection.
type EnergyFlowDirection string

// EnergyMeasurement defines model for EnergyMeasurement.
type EnergyMeasurement struct {
	Direction          EnergyFlowDirection   `json:"direction"`
	EnergyType         *EnergyType           `json:"energy_type,omitempty"`
	InitialMeasureTime *time.Time            `json:"initial_measure_time,omitempty"`
	MeasureTime        time.Time             `json:"measure_time"`
	Phase              PhaseIndicator        `json:"phase"`
	Unit               EnergyMeasurementUnit `json:"unit"`
	Value              float64               `json:"value"`
}

// EnergyMeasurementUnit defines model for EnergyMeasurementUnit.
type EnergyMeasurementUnit string

// EnergyType defines model for EnergyType.
type EnergyType string

// ErrorBody defines model for ErrorBody.
type ErrorBody struct {
	Message *string `json:"message,omitempty"`
}

// ForecastedBlock defines model for ForecastedBlock.
type ForecastedBlock struct {
	Capacity  string              `json:"capacity"`
	EndTime   time.Time           `json:"end_time"`
	Phase     PhaseIndicator      `json:"phase"`
	StartTime time.Time           `json:"start_time"`
	Unit      ForecastedBlockUnit `json:"unit"`
}

// ForecastedBlockUnit defines model for ForecastedBlockUnit.
type ForecastedBlockUnit string

// GroupCapacityForecast defines model for GroupCapacityForecast.
type GroupCapacityForecast struct {
	ForecastedBlocks []ForecastedBlock    `json:"forecasted_blocks"`
	GroupId          string               `json:"group_id"`
	Type             CapacityForecastType `json:"type"`
}

// GroupComplianceError defines model for GroupComplianceError.
type GroupComplianceError struct {
	ForecastedBlocks *[]ForecastedBlock `json:"forecasted_blocks,omitempty"`
	Message          string             `json:"message"`
}

// Heartbeat defines model for Heartbeat.
type Heartbeat struct {
	// OfflineModeAt A time in the future that indicates when, in case no more heartbeat
	// messages are received, it can be assumed the receiving party is
	// offline (unavailable). This time SHOULD be updated with every
	// heartbeat message.
	OfflineModeAt *time.Time `json:"offline_mode_at,omitempty"`
}

// InstantaneousMeasurement defines model for InstantaneousMeasurement.
type InstantaneousMeasurement struct {
	MeasureTime time.Time                    `json:"measure_time"`
	Phase       PhaseIndicator               `json:"phase"`
	Unit        InstantaneousMeasurementUnit `json:"unit"`
	Value       float64                      `json:"value"`
}

// InstantaneousMeasurementUnit defines model for InstantaneousMeasurementUnit.
type InstantaneousMeasurementUnit string

// MeasurementConfiguration defines model for MeasurementConfiguration.
type MeasurementConfiguration string

// PhaseIndicator defines model for PhaseIndicator.
type PhaseIndicator string

// Registration defines model for Registration.
type Registration struct {
	Token      string       `json:"token"`
	VersionUrl []VersionURL `json:"version_url"`
}

// RequiredBehaviour defines model for RequiredBehaviour.
type RequiredBehaviour struct {
	// HeartbeatInterval The interval (in seconds) in which the
	// sender of this response expects heartbeats to
	// receive. If provided, value must be 1 or higher.
	// If the sender is not interested in the heartbeat
	// of the receiver, this field can be omitted.
	HeartbeatInterval *int `json:"heartbeat_interval,omitempty"`

	// MeasurementConfiguration For determining how measurements are
	// aggregated. Providing multiple configurations
	// is allowed. An empty array represents no
	// configurations.
	MeasurementConfiguration *[]MeasurementConfiguration `json:"measurement_configuration,omitempty"`
}

// UpdateAssetMeasurements defines model for UpdateAssetMeasurements.
type UpdateAssetMeasurements struct {
	GroupId      string             `json:"group_id"`
	Measurements []AssetMeasurement `json:"measurements"`
}

// UpdateGroupMeasurements defines model for UpdateGroupMeasurements.
type UpdateGroupMeasurements struct {
	GroupId      string              `json:"group_id"`
	Measurements []EnergyMeasurement `json:"measurements"`
}

// VersionURL defines model for VersionURL.
type VersionURL struct {
	// BaseUrl Base URL of the API
	BaseUrl string `json:"base_url"`

	// Version Version of the API
	Version string `json:"version"`
}

// Authorization defines model for Authorization.
type Authorization = string

// XCorrelationID defines model for X-Correlation-ID.
type XCorrelationID = string

// XRequestID defines model for X-Request-ID.
type XRequestID = string

// XSegmentCount defines model for X-Segment-Count.
type XSegmentCount = int

// XSegmentIndex defines model for X-Segment-Index.
type XSegmentIndex = int

// AdjustGroupCapacityForecast defines model for AdjustGroupCapacityForecast.
type AdjustGroupCapacityForecast = GroupCapacityForecast

// GroupCapacityComplianceError defines model for GroupCapacityComplianceError.
type GroupCapacityComplianceError = GroupComplianceError

// Handshake defines model for Handshake.
type Handshake = RequiredBehaviour

// HandshakeAcknowledge defines model for HandshakeAcknowledge.
type HandshakeAcknowledge = RequiredBehaviour

// UpdateGroupCapacityForecast defines model for UpdateGroupCapacityForecast.
type UpdateGroupCapacityForecast = GroupCapacityForecast

// HandshakeCapacityOptimizerParams defines parameters for HandshakeCapacityOptimizer.
type HandshakeCapacityOptimizerParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// HeartbeatCapacityOptimizerParams defines parameters for HeartbeatCapacityOptimizer.
type HeartbeatCapacityOptimizerParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UnregisterCapacityOptimizerParams defines parameters for UnregisterCapacityOptimizer.
type UnregisterCapacityOptimizerParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// RegisterCapacityOptimizerParams defines parameters for RegisterCapacityOptimizer.
type RegisterCapacityOptimizerParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UpdateRegistrationCapacityOptimizerParams defines parameters for UpdateRegistrationCapacityOptimizer.
type UpdateRegistrationCapacityOptimizerParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UpdateAssetMeasurementsCapacityOptimizerParams defines parameters for UpdateAssetMeasurementsCapacityOptimizer.
type UpdateAssetMeasurementsCapacityOptimizerParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UpdateGroupCapacityForecastCapacityOptimizerParams defines parameters for UpdateGroupCapacityForecastCapacityOptimizer.
type UpdateGroupCapacityForecastCapacityOptimizerParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// AdjustGroupCapacityForecastCapacityProviderParams defines parameters for AdjustGroupCapacityForecastCapacityProvider.
type AdjustGroupCapacityForecastCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// GroupCapacityComplianceErrorCapacityProviderParams defines parameters for GroupCapacityComplianceErrorCapacityProvider.
type GroupCapacityComplianceErrorCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// HandshakeAcknowledgeCapacityProviderParams defines parameters for HandshakeAcknowledgeCapacityProvider.
type HandshakeAcknowledgeCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// HeartbeatCapacityProviderParams defines parameters for HeartbeatCapacityProvider.
type HeartbeatCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UnregisterCapacityProviderParams defines parameters for UnregisterCapacityProvider.
type UnregisterCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// RegisterCapacityProviderParams defines parameters for RegisterCapacityProvider.
type RegisterCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UpdateRegistrationCapacityProviderParams defines parameters for UpdateRegistrationCapacityProvider.
type UpdateRegistrationCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UpdateGroupMeasurementsCapacityProviderParams defines parameters for UpdateGroupMeasurementsCapacityProvider.
type UpdateGroupMeasurementsCapacityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// HandshakeFlexibilityProviderParams defines parameters for HandshakeFlexibilityProvider.
type HandshakeFlexibilityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// HandshakeAcknowledgeFlexibilityProviderParams defines parameters for HandshakeAcknowledgeFlexibilityProvider.
type HandshakeAcknowledgeFlexibilityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// HeartbeatFlexibilityProviderParams defines parameters for HeartbeatFlexibilityProvider.
type HeartbeatFlexibilityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UnregisterFlexibilityProviderParams defines parameters for UnregisterFlexibilityProvider.
type UnregisterFlexibilityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// RegisterFlexibilityProviderParams defines parameters for RegisterFlexibilityProvider.
type RegisterFlexibilityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UpdateRegistrationFlexibilityProviderParams defines parameters for UpdateRegistrationFlexibilityProvider.
type UpdateRegistrationFlexibilityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// UpdateGroupCapacityForecastFlexibilityProviderParams defines parameters for UpdateGroupCapacityForecastFlexibilityProvider.
type UpdateGroupCapacityForecastFlexibilityProviderParams struct {
	Authorization  Authorization   `json:"Authorization"`
	XRequestID     XRequestID      `json:"X-Request-ID"`
	XCorrelationID *XCorrelationID `json:"X-Correlation-ID,omitempty"`
	XSegmentIndex  *XSegmentIndex  `json:"X-Segment-Index,omitempty"`
	XSegmentCount  *XSegmentCount  `json:"X-Segment-Count,omitempty"`
}

// HandshakeCapacityOptimizerJSONRequestBody defines body for HandshakeCapacityOptimizer for application/json ContentType.
type HandshakeCapacityOptimizerJSONRequestBody = RequiredBehaviour

// HeartbeatCapacityOptimizerJSONRequestBody defines body for HeartbeatCapacityOptimizer for application/json ContentType.
type HeartbeatCapacityOptimizerJSONRequestBody = Heartbeat

// UnregisterCapacityOptimizerJSONRequestBody defines body for UnregisterCapacityOptimizer for application/json ContentType.
type UnregisterCapacityOptimizerJSONRequestBody = Registration

// RegisterCapacityOptimizerJSONRequestBody defines body for RegisterCapacityOptimizer for application/json ContentType.
type RegisterCapacityOptimizerJSONRequestBody = Registration

// UpdateRegistrationCapacityOptimizerJSONRequestBody defines body for UpdateRegistrationCapacityOptimizer for application/json ContentType.
type UpdateRegistrationCapacityOptimizerJSONRequestBody = Registration

// UpdateAssetMeasurementsCapacityOptimizerJSONRequestBody defines body for UpdateAssetMeasurementsCapacityOptimizer for application/json ContentType.
type UpdateAssetMeasurementsCapacityOptimizerJSONRequestBody = UpdateAssetMeasurements

// UpdateGroupCapacityForecastCapacityOptimizerJSONRequestBody defines body for UpdateGroupCapacityForecastCapacityOptimizer for application/json ContentType.
type UpdateGroupCapacityForecastCapacityOptimizerJSONRequestBody = GroupCapacityForecast

// AdjustGroupCapacityForecastCapacityProviderJSONRequestBody defines body for AdjustGroupCapacityForecastCapacityProvider for application/json ContentType.
type AdjustGroupCapacityForecastCapacityProviderJSONRequestBody = GroupCapacityForecast

// GroupCapacityComplianceErrorCapacityProviderJSONRequestBody defines body for GroupCapacityComplianceErrorCapacityProvider for application/json ContentType.
type GroupCapacityComplianceErrorCapacityProviderJSONRequestBody = GroupComplianceError

// HandshakeAcknowledgeCapacityProviderJSONRequestBody defines body for HandshakeAcknowledgeCapacityProvider for application/json ContentType.
type HandshakeAcknowledgeCapacityProviderJSONRequestBody = RequiredBehaviour

// HeartbeatCapacityProviderJSONRequestBody defines body for HeartbeatCapacityProvider for application/json ContentType.
type HeartbeatCapacityProviderJSONRequestBody = Heartbeat

// UnregisterCapacityProviderJSONRequestBody defines body for UnregisterCapacityProvider for application/json ContentType.
type UnregisterCapacityProviderJSONRequestBody = Registration

// RegisterCapacityProviderJSONRequestBody defines body for RegisterCapacityProvider for application/json ContentType.
type RegisterCapacityProviderJSONRequestBody = Registration

// UpdateRegistrationCapacityProviderJSONRequestBody defines body for UpdateRegistrationCapacityProvider for application/json ContentType.
type UpdateRegistrationCapacityProviderJSONRequestBody = Registration

// UpdateGroupMeasurementsCapacityProviderJSONRequestBody defines body for UpdateGroupMeasurementsCapacityProvider for application/json ContentType.
type UpdateGroupMeasurementsCapacityProviderJSONRequestBody = UpdateGroupMeasurements

// HandshakeFlexibilityProviderJSONRequestBody defines body for HandshakeFlexibilityProvider for application/json ContentType.
type HandshakeFlexibilityProviderJSONRequestBody = RequiredBehaviour

// HandshakeAcknowledgeFlexibilityProviderJSONRequestBody defines body for HandshakeAcknowledgeFlexibilityProvider for application/json ContentType.
type HandshakeAcknowledgeFlexibilityProviderJSONRequestBody = RequiredBehaviour

// HeartbeatFlexibilityProviderJSONRequestBody defines body for HeartbeatFlexibilityProvider for application/json ContentType.
type HeartbeatFlexibilityProviderJSONRequestBody = Heartbeat

// UnregisterFlexibilityProviderJSONRequestBody defines body for UnregisterFlexibilityProvider for application/json ContentType.
type UnregisterFlexibilityProviderJSONRequestBody = Registration

// RegisterFlexibilityProviderJSONRequestBody defines body for RegisterFlexibilityProvider for application/json ContentType.
type RegisterFlexibilityProviderJSONRequestBody = Registration

// UpdateRegistrationFlexibilityProviderJSONRequestBody defines body for UpdateRegistrationFlexibilityProvider for application/json ContentType.
type UpdateRegistrationFlexibilityProviderJSONRequestBody = Registration

// UpdateGroupCapacityForecastFlexibilityProviderJSONRequestBody defines body for UpdateGroupCapacityForecastFlexibilityProvider for application/json ContentType.
type UpdateGroupCapacityForecastFlexibilityProviderJSONRequestBody = GroupCapacityForecast

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /oscp/co/2.0/handshake)
	HandshakeCapacityOptimizer(c *gin.Context, params HandshakeCapacityOptimizerParams)

	// (POST /oscp/co/2.0/heartbeat)
	HeartbeatCapacityOptimizer(c *gin.Context, params HeartbeatCapacityOptimizerParams)

	// (DELETE /oscp/co/2.0/register)
	UnregisterCapacityOptimizer(c *gin.Context, params UnregisterCapacityOptimizerParams)

	// (POST /oscp/co/2.0/register)
	RegisterCapacityOptimizer(c *gin.Context, params RegisterCapacityOptimizerParams)

	// (PUT /oscp/co/2.0/register)
	UpdateRegistrationCapacityOptimizer(c *gin.Context, params UpdateRegistrationCapacityOptimizerParams)

	// (POST /oscp/co/2.0/update_asset_measurements)
	UpdateAssetMeasurementsCapacityOptimizer(c *gin.Context, params UpdateAssetMeasurementsCapacityOptimizerParams)

	// (POST /oscp/co/2.0/update_group_capacity_forecast)
	UpdateGroupCapacityForecastCapacityOptimizer(c *gin.Context, params UpdateGroupCapacityForecastCapacityOptimizerParams)

	// (POST /oscp/cp/2.0/adjust_group_capacity_forecast)
	AdjustGroupCapacityForecastCapacityProvider(c *gin.Context, params AdjustGroupCapacityForecastCapacityProviderParams)

	// (POST /oscp/cp/2.0/group_capacity_compliance_error)
	GroupCapacityComplianceErrorCapacityProvider(c *gin.Context, params GroupCapacityComplianceErrorCapacityProviderParams)

	// (POST /oscp/cp/2.0/handshake_acknowledge)
	HandshakeAcknowledgeCapacityProvider(c *gin.Context, params HandshakeAcknowledgeCapacityProviderParams)

	// (POST /oscp/cp/2.0/heartbeat)
	HeartbeatCapacityProvider(c *gin.Context, params HeartbeatCapacityProviderParams)

	// (DELETE /oscp/cp/2.0/register)
	UnregisterCapacityProvider(c *gin.Context, params UnregisterCapacityProviderParams)

	// (POST /oscp/cp/2.0/register)
	RegisterCapacityProvider(c *gin.Context, params RegisterCapacityProviderParams)

	// (PUT /oscp/cp/2.0/register)
	UpdateRegistrationCapacityProvider(c *gin.Context, params UpdateRegistrationCapacityProviderParams)

	// (POST /oscp/cp/2.0/update_group_measurements)
	UpdateGroupMeasurementsCapacityProvider(c *gin.Context, params UpdateGroupMeasurementsCapacityProviderParams)

	// (POST /oscp/fp/2.0/handshake)
	HandshakeFlexibilityProvider(c *gin.Context, params HandshakeFlexibilityProviderParams)

	// (POST /oscp/fp/2.0/handshake_acknowledge)
	HandshakeAcknowledgeFlexibilityProvider(c *gin.Context, params HandshakeAcknowledgeFlexibilityProviderParams)

	// (POST /oscp/fp/2.0/heartbeat)
	HeartbeatFlexibilityProvider(c *gin.Context, params HeartbeatFlexibilityProviderParams)

	// (DELETE /oscp/fp/2.0/register)
	UnregisterFlexibilityProvider(c *gin.Context, params UnregisterFlexibilityProviderParams)

	// (POST /oscp/fp/2.0/register)
	RegisterFlexibilityProvider(c *gin.Context, params RegisterFlexibilityProviderParams)

	// (PUT /oscp/fp/2.0/register)
	UpdateRegistrationFlexibilityProvider(c *gin.Context, params UpdateRegistrationFlexibilityProviderParams)

	// (POST /oscp/fp/2.0/update_group_capacity_forecast)
	UpdateGroupCapacityForecastFlexibilityProvider(c *gin.Context, params UpdateGroupCapacityForecastFlexibilityProviderParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// HandshakeCapacityOptimizer operation middleware
func (siw *ServerInterfaceWrapper) HandshakeCapacityOptimizer(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params HandshakeCapacityOptimizerParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HandshakeCapacityOptimizer(c, params)
}

// HeartbeatCapacityOptimizer operation middleware
func (siw *ServerInterfaceWrapper) HeartbeatCapacityOptimizer(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params HeartbeatCapacityOptimizerParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HeartbeatCapacityOptimizer(c, params)
}

// UnregisterCapacityOptimizer operation middleware
func (siw *ServerInterfaceWrapper) UnregisterCapacityOptimizer(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UnregisterCapacityOptimizerParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UnregisterCapacityOptimizer(c, params)
}

// RegisterCapacityOptimizer operation middleware
func (siw *ServerInterfaceWrapper) RegisterCapacityOptimizer(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterCapacityOptimizerParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RegisterCapacityOptimizer(c, params)
}

// UpdateRegistrationCapacityOptimizer operation middleware
func (siw *ServerInterfaceWrapper) UpdateRegistrationCapacityOptimizer(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateRegistrationCapacityOptimizerParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateRegistrationCapacityOptimizer(c, params)
}

// UpdateAssetMeasurementsCapacityOptimizer operation middleware
func (siw *ServerInterfaceWrapper) UpdateAssetMeasurementsCapacityOptimizer(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateAssetMeasurementsCapacityOptimizerParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateAssetMeasurementsCapacityOptimizer(c, params)
}

// UpdateGroupCapacityForecastCapacityOptimizer operation middleware
func (siw *ServerInterfaceWrapper) UpdateGroupCapacityForecastCapacityOptimizer(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateGroupCapacityForecastCapacityOptimizerParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateGroupCapacityForecastCapacityOptimizer(c, params)
}

// AdjustGroupCapacityForecastCapacityProvider operation middleware
func (siw *ServerInterfaceWrapper) AdjustGroupCapacityForecastCapacityProvider(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AdjustGroupCapacityForecastCapacityProviderParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AdjustGroupCapacityForecastCapacityProvider(c, params)
}

// GroupCapacityComplianceErrorCapacityProvider operation middleware
func (siw *ServerInterfaceWrapper) GroupCapacityComplianceErrorCapacityProvider(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GroupCapacityComplianceErrorCapacityProviderParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GroupCapacityComplianceErrorCapacityProvider(c, params)
}

// HandshakeAcknowledgeCapacityProvider operation middleware
func (siw *ServerInterfaceWrapper) HandshakeAcknowledgeCapacityProvider(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params HandshakeAcknowledgeCapacityProviderParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HandshakeAcknowledgeCapacityProvider(c, params)
}

// HeartbeatCapacityProvider operation middleware
func (siw *ServerInterfaceWrapper) HeartbeatCapacityProvider(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params HeartbeatCapacityProviderParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HeartbeatCapacityProvider(c, params)
}

// UnregisterCapacityProvider operation middleware
func (siw *ServerInterfaceWrapper) UnregisterCapacityProvider(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UnregisterCapacityProviderParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UnregisterCapacityProvider(c, params)
}

// RegisterCapacityProvider operation middleware
func (siw *ServerInterfaceWrapper) RegisterCapacityProvider(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterCapacityProviderParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RegisterCapacityProvider(c, params)
}

// UpdateRegistrationCapacityProvider operation middleware
func (siw *ServerInterfaceWrapper) UpdateRegistrationCapacityProvider(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateRegistrationCapacityProviderParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateRegistrationCapacityProvider(c, params)
}

// UpdateGroupMeasurementsCapacityProvider operation middleware
func (siw *ServerInterfaceWrapper) UpdateGroupMeasurementsCapacityProvider(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateGroupMeasurementsCapacityProviderParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateGroupMeasurementsCapacityProvider(c, params)
}

// HandshakeFlexibilityProvider operation middleware
func (siw *ServerInterfaceWrapper) HandshakeFlexibilityProvider(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params HandshakeFlexibilityProviderParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HandshakeFlexibilityProvider(c, params)
}

// HandshakeAcknowledgeFlexibilityProvider operation middleware
func (siw *ServerInterfaceWrapper) HandshakeAcknowledgeFlexibilityProvider(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params HandshakeAcknowledgeFlexibilityProviderParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HandshakeAcknowledgeFlexibilityProvider(c, params)
}

// HeartbeatFlexibilityProvider operation middleware
func (siw *ServerInterfaceWrapper) HeartbeatFlexibilityProvider(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params HeartbeatFlexibilityProviderParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.HeartbeatFlexibilityProvider(c, params)
}

// UnregisterFlexibilityProvider operation middleware
func (siw *ServerInterfaceWrapper) UnregisterFlexibilityProvider(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UnregisterFlexibilityProviderParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UnregisterFlexibilityProvider(c, params)
}

// RegisterFlexibilityProvider operation middleware
func (siw *ServerInterfaceWrapper) RegisterFlexibilityProvider(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterFlexibilityProviderParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RegisterFlexibilityProvider(c, params)
}

// UpdateRegistrationFlexibilityProvider operation middleware
func (siw *ServerInterfaceWrapper) UpdateRegistrationFlexibilityProvider(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateRegistrationFlexibilityProviderParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateRegistrationFlexibilityProvider(c, params)
}

// UpdateGroupCapacityForecastFlexibilityProvider operation middleware
func (siw *ServerInterfaceWrapper) UpdateGroupCapacityForecastFlexibilityProvider(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateGroupCapacityForecastFlexibilityProviderParams

	headers := c.Request.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Authorization, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Authorization: %w", err), http.StatusBadRequest)
			return
		}

		params.Authorization = Authorization

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter Authorization is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Required header parameter "X-Request-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-ID")]; found {
		var XRequestID XRequestID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Request-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-ID", valueList[0], &XRequestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Request-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XRequestID = XRequestID

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Request-ID is required, but not found"), http.StatusBadRequest)
		return
	}

	// ------------- Optional header parameter "X-Correlation-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Correlation-ID")]; found {
		var XCorrelationID XCorrelationID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Correlation-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Correlation-ID", valueList[0], &XCorrelationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Correlation-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XCorrelationID = &XCorrelationID

	}

	// ------------- Optional header parameter "X-Segment-Index" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Index")]; found {
		var XSegmentIndex XSegmentIndex
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Index, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Index", valueList[0], &XSegmentIndex, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Index: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentIndex = &XSegmentIndex

	}

	// ------------- Optional header parameter "X-Segment-Count" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Segment-Count")]; found {
		var XSegmentCount XSegmentCount
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Segment-Count, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Segment-Count", valueList[0], &XSegmentCount, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Segment-Count: %w", err), http.StatusBadRequest)
			return
		}

		params.XSegmentCount = &XSegmentCount

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateGroupCapacityForecastFlexibilityProvider(c, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/oscp/co/2.0/handshake", wrapper.HandshakeCapacityOptimizer)
	router.POST(options.BaseURL+"/oscp/co/2.0/heartbeat", wrapper.HeartbeatCapacityOptimizer)
	router.DELETE(options.BaseURL+"/oscp/co/2.0/register", wrapper.UnregisterCapacityOptimizer)
	router.POST(options.BaseURL+"/oscp/co/2.0/register", wrapper.RegisterCapacityOptimizer)
	router.PUT(options.BaseURL+"/oscp/co/2.0/register", wrapper.UpdateRegistrationCapacityOptimizer)
	router.POST(options.BaseURL+"/oscp/co/2.0/update_asset_measurements", wrapper.UpdateAssetMeasurementsCapacityOptimizer)
	router.POST(options.BaseURL+"/oscp/co/2.0/update_group_capacity_forecast", wrapper.UpdateGroupCapacityForecastCapacityOptimizer)
	router.POST(options.BaseURL+"/oscp/cp/2.0/adjust_group_capacity_forecast", wrapper.AdjustGroupCapacityForecastCapacityProvider)
	router.POST(options.BaseURL+"/oscp/cp/2.0/group_capacity_compliance_error", wrapper.GroupCapacityComplianceErrorCapacityProvider)
	router.POST(options.BaseURL+"/oscp/cp/2.0/handshake_acknowledge", wrapper.HandshakeAcknowledgeCapacityProvider)
	router.POST(options.BaseURL+"/oscp/cp/2.0/heartbeat", wrapper.HeartbeatCapacityProvider)
	router.DELETE(options.BaseURL+"/oscp/cp/2.0/register", wrapper.UnregisterCapacityProvider)
	router.POST(options.BaseURL+"/oscp/cp/2.0/register", wrapper.RegisterCapacityProvider)
	router.PUT(options.BaseURL+"/oscp/cp/2.0/register", wrapper.UpdateRegistrationCapacityProvider)
	router.POST(options.BaseURL+"/oscp/cp/2.0/update_group_measurements", wrapper.UpdateGroupMeasurementsCapacityProvider)
	router.POST(options.BaseURL+"/oscp/fp/2.0/handshake", wrapper.HandshakeFlexibilityProvider)
	router.POST(options.BaseURL+"/oscp/fp/2.0/handshake_acknowledge", wrapper.HandshakeAcknowledgeFlexibilityProvider)
	router.POST(options.BaseURL+"/oscp/fp/2.0/heartbeat", wrapper.HeartbeatFlexibilityProvider)
	router.DELETE(options.BaseURL+"/oscp/fp/2.0/register", wrapper.UnregisterFlexibilityProvider)
	router.POST(options.BaseURL+"/oscp/fp/2.0/register", wrapper.RegisterFlexibilityProvider)
	router.PUT(options.BaseURL+"/oscp/fp/2.0/register", wrapper.UpdateRegistrationFlexibilityProvider)
	router.POST(options.BaseURL+"/oscp/fp/2.0/update_group_capacity_forecast", wrapper.UpdateGroupCapacityForecastFlexibilityProvider)
}
